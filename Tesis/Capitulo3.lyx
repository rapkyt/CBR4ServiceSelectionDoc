#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass myBook
\begin_preamble
\usepackage{url}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language spanish
\language_package babel
\inputencoding auto
\fontencoding default
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 0
\use_package cancel 0
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Proposal
\begin_inset CommandInset label
LatexCommand label
name "chap:Proposal"

\end_inset


\end_layout

\begin_layout Section
Introducción
\end_layout

\begin_layout Standard
Como se mencionó en la Sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Solución-propuesta"

\end_inset

 (Capítulo 1), el objetivo principal de este trabajo es mejorar el Método
 de Selección de Servicios Web presentado en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:SelectionMethodOld"

\end_inset

 (Capítulo
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "cap:SOApp"

\end_inset

).
 En este contexto, uno de los desafíos más importantes a la hora de evaluar
 Servicios Web, es contar con una especificación de contratos de servicios
 que sea lo suficientemente descriptiva en cuanto a las funcionalidades
 que ofrece cada Servicio Web.
 Para lidiar con este desafío, se propuso definir y desarrollar una especificaci
ón de contratos de Servicios Web, que sea independiente de cualquier tecnología
 de implementación.
 Algunas soluciones para problemas similares
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "garriga2015web"

\end_inset

 se basan en estándares existentes como WSDL
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "d2006model"

\end_inset

, o bien proponen especificaciones ad-hoc
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "narayanan2002simulation,chan2008dynamic"

\end_inset

.
\end_layout

\begin_layout Standard
Con el fin de satisfacer el objetivo mencionado, el Metamodelo de descripciones
 de Servicios Web heterogéneos fue extendido, incorporándolo en una nueva
 estructura llamada 
\begin_inset Quotes eld
\end_inset

Caso
\begin_inset Quotes erd
\end_inset

 y un nuevo componente Conversor de especificaciónes Swagger hacia instancia
 del 
\begin_inset Quotes eld
\end_inset

Caso
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
El resto del capítulo se distribuye de la siguiente manera: en la Sección
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:CBR-para-selección"

\end_inset

 se presenta el trabajo que se llevó a cabo para poder utilizar el Metamodelo
 para Descripción de Servicios Web dentro del CBR.
 En la Sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:-Conversor de OAS"

\end_inset

 se detalla el Componente Conversor de Swagger para instanciar el Metamodelo
 de Servicios Web.
 Finalmente, en la Sección
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Intregracion-a-Testooj"

\end_inset

 
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Ejemplo-Ilustrativo"

\end_inset

Ejemplo Ilustrativo
\end_layout

\begin_layout Standard
Durante el desarrollo de este trabajo se tomará como soporte a la explicación,
 un Servicio Web REST
\begin_inset CommandInset citation
LatexCommand cite
key "thomas2000fielding"

\end_inset

 perteneciente al dominio de veterinaria (PetStore).
 Este servicio nos brinda la posibilidad de realizar altas, bajas y consulta
 de las mascotas cargadas en el sistema, como así también cargar imagenes
 de las mismas.
 El diagrama de clases UML para este dominio es presentado en la Figura
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig: caso de estudio-1"

\end_inset

 en donde referenciaremos las operaciones con el formato 
\emph on
{Método HTTP}_{URI}
\emph default
 para que puedan ser identificadas inequívocamente, además se encapsularán
 los parametros de entrada por URL con llaves, por ejemplo, 
\emph on
{petId}, 
\emph default
se reemplazará por el id de la mazcota deseada.
 Este servicio está compuesto por cinco operaciones encapsuladas en la interfaz
 petStore, 
\emph on
POST_/pet, GET_/pet/{petId}, POST_/pet/{petId}, DELETE_/pet/{petId} y POST_/pet/
{petId}/uploadImage
\emph default
.
 La operación 
\emph on
POST_/pet
\emph default
 es utilizada para agregar mascotas a la base de datos, devolviendo los
 datos de la misma, y un id único.
 Para 
\emph on
GET_/pet/{petId}
\emph default
, dado un id 
\emph on

\begin_inset Quotes eld
\end_inset

petId
\begin_inset Quotes erd
\end_inset


\emph default
 de una mascota, retorna la información de esa mascota, a su vez 
\emph on
POST_/pet/{petId} 
\emph default
recibe el mísmo id de la mascota, más los datos a actualizar de la misma,
 
\emph on
DELETE_/pet/{petId}
\emph default
 recibe el id de una mascota y luego la elimina.
 Finalmente, 
\emph on
POST_/pet/{petId}/uploadImage
\emph default
 es una operación que recibe el id de una mascota y una imagen, almacena
 la imagen y agrega la 
\emph on
URL
\emph default
 de la misma a la propiedad 
\emph on
photoUrls
\emph default
 de la mascota con el mismo id.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ImgChapter3/usadas/OAS vs Metamodelo.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig: caso de estudio-1"

\end_inset

Visión esquemática UML del Caso de estudio
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:CBR-para-selección"

\end_inset

Razonamiento Basado en Casos para selección de Servicios Web
\end_layout

\begin_layout Standard
En esta sección se describe cada 
\emph on
paso
\emph default
 que compone al diagrama de flujo de la Figura
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Esquema-de-proceso"

\end_inset

.
 El mismo comienza cuando se ingresa al sistema una consulta, un caso, con
 
\emph on
problema
\emph default
 y sin 
\emph on
solución
\emph default
, este es llamado 
\emph on
New Case
\emph default
, lo que sucede a continuación es que se compara uno a uno con los casos
 de la base de conocimiento (
\emph on
Knowledge Base
\emph default
), los cuales poseen tanto 
\emph on
problema
\emph default
 como 
\emph on
solución
\emph default
.
 Se calcula cuán distinto es el problema del nuevo 
\emph on
caso
\emph default
 con cada uno de los demás problemas, para esto se utiliza la funcion de
 distancia del 
\emph on
Metamodelo.
 
\emph default
La distancia entre dos casos nos indica cuán parecido son sus problemas,
 una distancia de 0.0 nos indica que los problemas son idénticos, por el
 contrario una distancia de 4.0 nos indica que ambas interfaces son totalmente
 incompatibles.
 La distancia nos indica además, el esfuerzo que va a requerir adaptar ambas
 interfaces, siendo 0.0 ningún esfuerzo, y 4.0 imposible.
 Una distancia entre esos dos valores, nos indica que deberemos crear componente
s para utilizar el patrón de diseño adapter
\begin_inset CommandInset citation
LatexCommand cite
key "GoF"

\end_inset

 y, de esta manera permitir la compatibilidad entre ambos servicios.
 Para seleccionar el servicio adecuado se útilizan métodos de selección
 como 
\emph on
K-nn, WK-nn
\emph default
 y 
\emph on
DWK-nn
\emph default
.
 
\emph on
K-nn 
\emph default
consiste en tomar las 
\emph on
K
\emph default
 soluciones de los casos con menor distancia distancia y seleccionar la
 mas frecuente (puesto a que dos casos en la base de conocimiento pueden
 tener la misma solución), en caso de empate se elige la solución del caso
 con menor distancia.
 La misma pasa a ser la solución 
\emph on
ganadora
\emph default
 y es asignada al caso candidato (ahora 
\emph on
Solved Case
\emph default
).
 Los métodos de selección 
\emph on
WK-nn
\emph default
 y 
\emph on
DWK-nn
\emph default
 son desarrollados en 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:Resolviendo-el-Caso"

\end_inset

.
 El caso candidato se presenta al consumidor y éste decide si la solución
 es compatible o no, en caso de que no lo sea, dicha solución es descartada
 y el consumidor puede volver a iniciar el proceso de resolución si éste
 lo desea.
 
\end_layout

\begin_layout Standard
Si la solución es compatible, se evalúa la calidad de la respuesta, para
 ésto se compara un valor de 
\emph on
threshold
\emph default
, si la solución tiene un valor MAYOR que el establecido, el nuevo caso
 con su solución son agregados a la base de conocimiento y, de ésta manera,
 es tomada en cuenta para futuras consultas.
 En caso de que el valor sea menor que el establecido, este caso no se agrega,
 debido a que generaría ruidos y posiblemente haría overfitting al proceso,
 haciendo que al llegar un nuevo caso, genere falsos positivos, es decir
 que diga que no hay distancia entre el caso requerido y la solución de
 un caso de la base de conocimiento, cuando en realidad existe una distancia
 significativa.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename ImgChapter3/usadas/CBR 4SS.png
	lyxscale 70
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Esquema-de-proceso"

\end_inset

Esquema de proceso propuesto
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Vision-Detallada"

\end_inset

Visión Detallada
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Discutir en detalle cada una, ver el paper de CBR.
 Por ejemplo:
\end_layout

\begin_layout Plain Layout
Numerar los pasos en la figura (find, resolve, revise, retrain, discard,
 etc).
 Luego usar esa numeración para describir cada parte del proceso en la visión
 detallada.
\end_layout

\begin_layout Plain Layout
1.
 Case Representation.
 entra un caso (como esta compuesto?) que tiene que ver con el metamodelo?
 Ejemplificar
\end_layout

\begin_layout Plain Layout
2.
 KB.
 Persistencia, noSQL , json-oriented.
 Ejemplo!
\end_layout

\begin_layout Plain Layout
3.
 Find Similarity (Case retrieval en el paper CBR).
 se evalua segun la funcion (mostrar la funcion de distanca, explicarla).
 Ejemplo.
 
\end_layout

\begin_layout Plain Layout
4.
 Resolve Case (Reuse and Revision en CBR): Técnicas (knn, 1-nn) cual se
 usó, por qué? Es configurable! No se está haciendo la parte de adaptación
 del caso (debido al dominio de aplicación)
\end_layout

\begin_layout Plain Layout
5.
 Evaluate and Case Retrain (Case Retraining en el paper de CBR).
 
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Representación del Caso
\begin_inset Newline newline
\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Como numero la imagen?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Como primer paso, es escencial definir como está compuesto un Caso a resolver,
 el mismo consta con dos atributos principales, 
\emph on
problema
\emph default
 y 
\emph on
solución
\emph default
.
 El problema es una referencia a una instancia de la clase 
\emph on
Interface
\emph default
 del 
\emph on
Metamodelo
\emph default
, de este modo, el 
\emph on
problema
\emph default
 es una representación de la especificación técnica del servicio que se
 desea resolver o ha sido resuelto previamente.
 La 
\emph on
solución
\emph default
 es un atributo, que en los casos a resolver será 
\emph on
nulo
\emph default
, pues el caso no está resuelto, y que en caso contrario tendrá como valor
 un 
\emph on
String 
\emph default
indicando inequívocamente la 
\emph on
ubicación 
\emph default
de la solución para dicho caso, éste puede ser la dirección web donde se
 encuentra alojado el servicio web detallado en el problema, por ejemplo.
\end_layout

\begin_layout Standard
Un 
\emph on
Caso
\emph default
 sin solución va a ser introducido en nuestro CBR para obtener un nuevo
 
\emph on
Caso
\emph default
 con la solución más próxima que satisfaga las necesidades del problema.
\end_layout

\begin_layout Standard
En la figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:EjemploVersionCaseInstanciada"

\end_inset

 podemos observar el driagrama de clases instanciado para la representación
 de un 
\emph on
Caso 
\emph default
cuyo problema es la interfaz definida en 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Ejemplo-Ilustrativo"

\end_inset

, en la misma se observa como el problema es la instancia de una interfaz,
 la misma contiene cinco operaciones, a modo ilustrativo sólo se expandió
 la operación 
\emph on
GET_/pet/{petId}
\emph default
 hasta llegar a los 
\emph on
tipos 
\emph default
utilizados
\emph on
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ImgChapter3/usadas/OAS vs Metamodelo (instancia Case).png
	lyxscale 80
	width 100col%
	scaleBeforeRotation

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:EjemploVersionCaseInstanciada"

\end_inset

Ejemplo de 
\emph on
Caso
\emph default
 instanciado para el caso de estudio
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Base de conocimiento
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Para el Razonamiento basado en casos es de suma importancia poseer una buena
 base de conocimiento, pues justamente, es utilizada para buscar el mejor
 caso candidato entre los casos previamente aprendidos.
 Esta base de conocimientos o 
\emph on
KB
\emph default
 debe ser persistente entre distintas ejecuciones del 
\emph on
CBR
\emph default
, de otra manera, no se dispondran de los casos aprendidos en ejecuciones
 pasadas.
 Para la carga inicial se utilizaron servicios reales
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://apis.guru/openapi-directory
\end_layout

\end_inset


\end_layout

\end_inset

, por cada uno se genera una instancia del metamodelo con su especificación,
 se toma la 
\emph on
interface
\emph default
 de la misma y se le asigna a como 
\emph on
problema 
\emph default
a un nuevo 
\emph on
caso
\emph default
, se le asigna la URL donde se encuentra actualmente el servicio como 
\emph on
solución
\emph default
 y luego el caso es cargado en la base de conocimiento, de esta manera,
 el CBR posee una base de conocimiento inicial, con la cual comenzar la
 comparación e ir incorporando nuevos casos según sea necesario.
\end_layout

\begin_layout Standard
Para el almacenamiento de esta base de conocimientos se decidió utilizar
 una base de datos no-sql basada en documentos (no relacional) llamada MongoDB
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.mongodb.com/what-is-mongodb
\end_layout

\end_inset


\end_layout

\end_inset

.
 Se tomó esta desición puesto a que: 
\end_layout

\begin_layout Itemize
El 
\emph on
Caso
\emph default
 que se desea almacenar se puede representar como un sólo documento, u objeto
 JSON
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.json.org/
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
El lenguaje de marcado con el cual se guardan y editan los documentos es
 JSON, el mismo que se utiliza en las especificaciones Swagger.
\end_layout

\begin_layout Itemize
Salvo las instancias de las clases 
\emph on
SimpleType
\emph default
, 
\emph on
ComplexType 
\emph default
y 
\emph on
ArrayType
\emph default
, no vamos a tener otras instancias identicas entre sí 
\begin_inset Note Note
status open

\begin_layout Plain Layout
¿?
\end_layout

\end_inset

 que nos haga reducir espacio de almacenamiento al tener el registro cargado
 una única vez en una tabla, y referenciando al mismo 
\emph on
ID 
\emph default
desde otra.
\end_layout

\begin_layout Itemize
A la hora de consultar un caso siempre lo realizaremos desde la raíz del
 mismo, y para decidir si es o no compatible tenemos que explorar todas
 las relaciones, si utilizaramos una base de datos relacional y consultaramos
 un 
\emph on
Case 
\emph default
cuyo problema consiste de una entrada, una salida, una falta y tenga al
 menos un parametro de cada clase concreta de Type, esto se traduciría en
 el acceso a todas las tablas (Case, Interface, Operation, Input, Output,
 Fault, Parameter, ArrayType, SimpleType, ComplexType y Attribute) que implicarí
a al menos once consultas o 
\emph on
hits
\emph default
 a la base de datos, por otro lado, si utilizamos una base de datos orientada
 a documentos, por cada caso que deseamos comparar con el caso de entrada
 realizaremos una sola consulta, o 
\emph on
hit
\emph default
 a la base de datos, utilizando la totalidad del documento, es decir, no
 se habrán traído datos innecesarios.
\end_layout

\begin_layout Itemize
La performance que ofrecen las bases de datos no relacionales frente a las
 bases de datos relacionales es muy superior como se puede observar en 
\begin_inset Note Note
status open

\begin_layout Plain Layout
meter estudios de benchmark
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
Por otro lado, una común desventaja que presentan los sistemas de base de
 datos no-sql frente a uno relacional, es la falta de las propiedades ACID,
 MongoDB 4.0 CUMPLE ACID???? 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Probar MongoDB 4.0, si cumple acid decir que hasta la v 4.0 no se cumplía
 acid, que a nosotros no nos importa xq necesitamos transaccion a nivel
 de documento, en caso que cumpla ACID, decir que en muchos casos no se
 cumple, que esa es una característica por la cual muchos no lo utilizan,
 a nosotros no nos importa xq necesitamos transacción a nivel de documento,
 pero si se cumple así que es lo mismo
\end_layout

\end_inset


\end_layout

\begin_layout Standard
MongoDB es un Sistema de Base de Datos basado en Documentos Open Source
 ampliamente utilizada en el mercado, posicionandose dentro de los 10 Sistemas
 de Base de Datos utilizados independientemente del típo (Relacional, Key-value,
 basada en Documentos, orientada a Grafos, basada en series de tiempo, basada
 en RDF, orientada a Objetos, motor de busqueda, basada en Wide column,
 nativa XML, repositirio de contenidos, basada en eventos y Navigational)
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://db-engines.com/en/ranking
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
reemplazar por referencia incluyendo fecha de extracción?
\end_layout

\end_inset

 y en el primer puesto dentro de los Sistemas de Base de Datos basados en
 documentos
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://db-engines.com/en/ranking/document+store
\end_layout

\end_inset


\end_layout

\end_inset

.
 El mismo se eligió ya que es el standar de facto en cuanto a Sistemas de
 Base de Datos basados en documentos, es Open Source, lo cual nos brinda
 flexibilidad si necesitaramos modificar su funcionamiento, posee una documentac
ión muy completa 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://docs.mongodb.com/manual
\end_layout

\end_inset


\end_layout

\end_inset

 y además es gratiuto incluso su última versión, al contrario de 
\emph on
Couchbase
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.couchbase.com/
\end_layout

\end_inset


\end_layout

\end_inset


\emph on
 
\emph default
otro sistema de Base de Datos basado en Documentos Open Source, que la última
 versión es paga, y la anterior a esa es gratiuta, tageada como CE (Comunity
 Edition).
\end_layout

\begin_layout Standard
En 
\begin_inset CommandInset ref
LatexCommand ref
reference "Documento PetStore almacenado en MongoDB"

\end_inset

 se puede observar un fragmento de como quedaría un objeto JSON conteniendo
 un 
\emph on
Caso
\emph default
 cuyo 
\emph on
problema
\emph default
 es la especificacion la instancia del metamodelo del ejemplo 
\emph on
PetStore
\emph default
 indicado en 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Ejemplo-Ilustrativo"

\end_inset

, dicho objeto JSON es almacenado en la Base de Conocimiento 
\emph on
KB
\emph default
 en el Sistema de Base de Datos MongoDB.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "listing/petStore(mongo) (short).txt"
lstparams "breaklines=true,basicstyle={\\ttfamily\\scriptsize},caption={Documento PetStore almacenado en MongoDB},label={Documento PetStore almacenado en MongoDB}"

\end_inset


\end_layout

\begin_layout Paragraph
Busqueda de casos similares
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Un 
\emph on
Caso
\emph default
 sin 
\emph on
solución
\emph default
 va a ser introducido en nuestro CBR, cuyo 
\emph on
problema 
\emph default
va a constar de la especificación de la funcionalidad requerida.
 Para obtener una solución a este nuevo 
\emph on
Caso
\emph default
, lo primero que se debe hacer es calcular la funcion de similitud (DIST),
 como la distancia entre el nuevo 
\emph on
Caso 
\emph default
y cada caso perteneciente a la base de conocimientos 
\emph on
KB
\emph default
, de acuerdo a la formula 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:DIST"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "80col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{equation}
DIST(C^{n},C^{c})=\sum_{1}^{n}(w_{i}*sim(C_{i}^{n},C_{i}^{c}))\label{eq:DIST}
\end{equation}

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\size small
Donde 
\begin_inset Formula $C^{n}$
\end_inset

 es el nuevo 
\emph on
Caso 
\emph default
a evaluar y 
\begin_inset Formula $C^{C}$
\end_inset

 es el 
\emph on
Caso 
\emph default
candidato obtenido de la base de conocimientos 
\emph on
KB
\emph default
.
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Y donde la función de similitud es: ....
\begin_inset Note Note
status open

\begin_layout Plain Layout
agregar info de funcion de similitud.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si comparamos el problema XXX con el ejemplificado en 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Ejemplo-Ilustrativo"

\end_inset

 podemos observar como la función de distancia da...
 por....
\end_layout

\begin_layout Paragraph
\begin_inset CommandInset label
LatexCommand label
name "par:Resolviendo-el-Caso"

\end_inset

Resolviendo el Caso
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Una vez calculadas las distancias de cada uno de los casos candidatos con
 el nuevo 
\emph on
Caso
\emph default
, las mismas son introducidas en una lista a modo de tupla 
\begin_inset Formula $(Solución,\,Distancia)$
\end_inset

, luego ésta lista es ordenada según la distancia y utilizada con el fin
 de encontrar el Caso Candidato final.
\end_layout

\begin_layout Standard
Las estrategias para la selección de éste Caso Candidato final entre la
 lista de casos candidatos son 
\emph on
1-nn
\emph default
, 
\emph on
K-nn
\emph default
, 
\emph on
WK-nn
\emph default
 y 
\emph on
DWK-nn
\emph default
.
\end_layout

\begin_layout Itemize

\emph on
1-nn
\emph default
 Consiste en simplemente seleccionar la 
\emph on
Solución
\emph default
 cuya 
\emph on
distancia
\emph default
 sea la menor.
\end_layout

\begin_layout Itemize

\emph on
k-nn 
\emph default
Consiste en tomar las 
\emph on
k 
\emph default
soluciones con menor distancia y tomar la 
\emph on
Solución
\emph default
 mas frecuente entre las mismas.
\end_layout

\begin_layout Itemize

\emph on
WK-nn
\emph default
 o 
\emph on
weighted k-NN 
\emph default
y
\emph on
 DWK-nn 
\emph default
o 
\emph on
Distance-weighted knn 
\emph default
consisten en tomar las k soluciones con menor distancia, ponderar el peso
 de cada solución con la fórmula 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:WKNN"

\end_inset

 en el caso de 
\emph on
WK-nn 
\emph default
o 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:DWKNN"

\end_inset

 en el caso de 
\emph on
DWK-nn
\emph default
, agrupar las mismas por solucion sumando el peso ponderado de cada una
 y tomar la 
\emph on
Solución
\emph default
 con mayor peso, ambas estrategias nos permiten ...
\end_layout

\begin_layout Standard
Como saco éste texto?
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "80col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{equation}
w(i)=\frac{d^{k}-d^{i}}{d^{k}-d^{1}}\label{eq:WKNN}
\end{equation}

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{equation}
w(i)=\frac{d^{k}-d^{i}}{d^{k}-d^{1}}\times\frac{d^{k}+d^{1}}{d^{k}+d^{i}}\label{eq:DWKNN}
\end{equation}

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\size small
Donde 
\begin_inset Formula $d^{k}$
\end_inset

 es la distancia de la solución en la posición 
\emph on
k
\emph default
, 
\begin_inset Formula $d^{1}$
\end_inset

 es la distancia de la solución con menor distancia y 
\begin_inset Formula $d^{i}$
\end_inset

 es la distancia en la posición a calcular el peso
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La elección tanto de la estrategia a utilizar, así como del valor de 
\emph on
K 
\emph default
se realiza por medio de la configuración de variables de entorno a la hora
 de ejecutar el algoritmo de CBR.
\end_layout

\begin_layout Standard
Una vez que se obtiene el Caso Candidato final mediante la estrategia selecciona
da, se toma la 
\emph on
solución 
\emph default
del mismo, y se devuelve.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
feedback de experto?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Según la teoría de Case Based Reasoning, se puede realizar una adaptación
 de la solución para que concuerde con el problema ingresado, 
\begin_inset Note Note
status open

\begin_layout Plain Layout
poner ejemplo típico de precio de auto-casa?
\end_layout

\end_inset

.
 En el dominio en el que se desarrolla nuestro razonador esta adaptación
 se realizaría de forma manual por el desarrollador, que busca una solución
 a su problema.
 El mismo deberá realizar los cambios necesarios en su interfaz para que
 la misma sea compatible con la interfaz de la solución brindada.
\end_layout

\begin_layout Standard
La adaptación automática de 
\emph on
Casos
\emph default
 es un proceso complejo que queda fuera del alcanze de esta tesis y disponible
 como trabajo a futuro.
\end_layout

\begin_layout Standard
Ejemlo...
\begin_inset Note Note
status open

\begin_layout Plain Layout
agregar relación caso study?
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Evaluar y retener
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
En esta instancia, el 
\emph on
Razonador Basado en Casos 
\emph default
ya comparó el caso de entrada con el problema de cada uno de los casos en
 la base de conocimientos (KB) y, se espera, haya encontrado una solución
 al mismo en terminos de la similitud de atributos vista anteriormente.
 Esta solución fue revisada y marcada como válida por el usuario experto,
 es decir, es una solución válida y el problema introducido, junto con la
 solución, pasan a ser un caso probado.
 El siguiente paso consiste en tomar la desición respecto a si éste caso
 probado será añadido a la base de conocimientos, o no.
 Por un lado, retener demasiados casos puede generar ruido en la evaluación,
 disminuyendo la performance del razonador a largo plazo.
 Por otro lado, si no se agregan casos nuevos, no hay aprendizaje, y el
 razonador no será capaz de resolver correctamente nuevos casos.
 Para prevenir que esto suceda se define un valor de threshold 
\emph on
(th)
\emph default
 o umbral
\emph on
 
\emph default
sobre la función de distancia 
\emph on
(DIST)
\emph default
.
 Dicho valor de umbral determina si el nuevo caso es retenido (
\emph on
caso aprendido
\emph default
) en la 
\emph on
KB
\emph default
.
 Si el valor de la distancia es MAYOR??? que el valor de threshold, entonces
 el caso es agregado a la base de conocimientos como un caso relevante,
 de otro modo es descartado.
 El objetivo es prevenir el crecimiento incontrolable de la 
\emph on
KB,
\emph default
 y al mismo tiempo, mejorar la performance del razonador.
 El valor de threshold o umbral es una constante que se configura mediante
 una variable de entorno a la hora de ejecutar el algoritmo, la misma debería
 tomar valores distintos dependiendo de la cantidad de casos iniciales.
 Si la misma es baja, se debería utilizar un valor BAJO???, permitiendo
 que el razonador añada casos para enriquecer la KB.
 Si el número de casos crece en un momento determinado, el valor de threshold
 puede ser DISMINUIDO? para agregar sólo casos relaventes.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Cambios-necesarios"

\end_inset

Cambios necesarios
\end_layout

\begin_layout Standard
En el diagrama de flujo de la Figura
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Esquema-de-proceso"

\end_inset

 se puede observar dentro del cuadro con bordes punteados como se componen
 las clases pertenecientes al Metamodelo SoaML, el mismo cumple su función
 como descriptor de interfaces, pero no tiene toda la información necesaria
 para operar dentro del contexto de un CBR.
\end_layout

\begin_layout Standard
Por lo tanto fue necesario realizar adaptaciones con el fin de operar dentro
 del marco de 
\emph on
Razonamiento Basado en Casos (CBR)
\emph default
.
\end_layout

\begin_layout Standard
Dichos cambios consisten en la creación de una nueva clase contenedora llamada
 
\emph on
Case
\emph default
, la misma posee un atributo llamado 
\emph on
problem
\emph default
, referenciando a la 
\emph on
Interface 
\emph default
descriptora del servicio, y otro atributo nombrado 
\emph on
solution
\emph default
, siendo éste un string que referencia unequivocamente la solución del problema
 descripto, el mismo puede ser cadena nula si se trata de un nuevo caso
 a consultar.
\end_layout

\begin_layout Standard
Es de gran importancia para el funcionamiento del 
\emph on
Razonamiento Basado en Casos (CBR)
\emph default
 almacenar los casos en una 
\emph on
Base de Conocimiento 
\emph default
(
\emph on
Knowledge Base
\emph default
 o KB), en la cual luego podremos hacer consultas, para la implementación
 de dicha base de conocimiento se decidió utilizar una Base de Datos basada
 en documentos (NoSQL) llamada 
\emph on
Mongo
\emph default
.
 Para poder almacenar nuestro caso en una base de datos lo ideal es serializarlo
, para obtener el valor de la base de datos se debe des serializar.
 Para realizar ambas acciones se optó por utilizar la librería 
\emph on
Jackson
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/FasterXML/jackson-module-kotlin
\end_layout

\end_inset


\end_layout

\end_inset

, que es el estardar de facto para realizar dichas tareas en Kotlin.
 Debido a que 
\emph on
Parameter
\emph default
 referencia al tipo de dato abstracto 
\emph on
Type
\emph default
, al momento de des serializarlo es necesario especificar a qué clase concreta
 pertenece el dato en cuestión, para ésto fue necesario modificar los constructo
res de la clase 
\emph on
Type
\emph default
, añadiendo anotaciones 
\emph on
(Annotations
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://docs.oracle.com/javase/7/docs/technotes/guides/language/annotations.html
\end_layout

\end_inset


\end_layout

\end_inset


\emph on
) 
\emph default
a los mismos, las anotaciones siguen el patrón decorator
\begin_inset CommandInset citation
LatexCommand cite
key "GoF"

\end_inset

.
\end_layout

\begin_layout Standard
Con estos cambios fue posible la utilización del Metamodelo SoaML dentro
 del contexto de 
\emph on
Razonamiento Basado en Casos (CBR)
\emph default
.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:-Conversor de OAS"

\end_inset

Conversor Swagger para instanciar el Metamodelo de Servicios Web
\end_layout

\begin_layout Standard
En la Sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Relación-entre-OAS"

\end_inset

 se analiza la relación existente entre el estándar Swagger y el metamodelo
 utilizado como modelador de problema, utilizando como soporte a la explicación
 un caso de estudio.
 Esta relación se analizará en profundidad, detallando la relación entre
 los componentes del Metamodelo y los de Swagger.
 Finalmente se muestra un diagrama de objetos instanciados de acuerdo al
 caso de estudio.
\end_layout

\begin_layout Standard
En la Sección
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Construcción-del-instanciador"

\end_inset

, se explica como se construyó el componente Conversor del metamodelo propuesto,
 detallando las estructuras de datos analizadas y el proceso de análisis
 que se realiza para poder instanciar el metamodelo a partir de una descripción
 swagger.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Casi todo lucas
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Relación-entre-OAS"

\end_inset

Relación entre Swagger y Metamodelo
\end_layout

\begin_layout Standard
En esta subsección se detalla la correlación entre el estándar Swagger y
 el Metamodelo de Servicios Web, para lo cual se utilizará un caso de estudio
 sencillo como soporte a la explicación.
 
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:Caso-de-estudio"

\end_inset

Caso de estudio
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
En el Listado de Código 
\begin_inset CommandInset ref
LatexCommand ref
reference "Documento OAS PetStore"

\end_inset

 se muestra un fragmento de la espicificación swagger que describe el servicio
 
\emph on
PetStore
\emph default
 descripto en 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Ejemplo-Ilustrativo"

\end_inset

, en el mismo se han eliminado las operaciones que no se utilizaran para
 explicar la relación entre la especificación swagger y el Metamodelo, la
 especificación completa se encuentra en XXXX
\begin_inset Note Note
status open

\begin_layout Plain Layout
Apéndice con la especificación completa, no la ofrecemos, o pongo el link?
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "listing/petStore (ejemplo).txt"
lstparams "breaklines=true,basicstyle={\\ttfamily\\scriptsize},caption={Documento OAS PetStore},label={Documento OAS PetStore}"

\end_inset


\end_layout

\begin_layout Paragraph
Swagger vs.
 Metamodelo
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Explicar el evaluador no incluye los simbolos
\end_layout

\end_inset

En el fragmento de Swagger – Listado de Código
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "Documento OAS PetStore"

\end_inset

, línea 
\begin_inset Note Note
status open

\begin_layout Plain Layout
DEFINIR
\end_layout

\end_inset

 –, se define para la interfaz (
\emph on
interface
\emph default
) del servicio, la operación (
\emph on
operation
\emph default
) 
\emph on
GET_/pet/{petId}
\emph default
, indicando la entrada y salida de la misma utilizando las keys 
\emph on
parameters
\emph default
 y 
\emph on
responses[200] 
\emph default
respectivamente.
 Cada entrada y cada salida se representa como una entrada del documento
 swagger.
 Los elementos que conforman las entradas y salidas de las operaciones se
 detallan dentro del apartado 
\emph on
types
\emph default
 del documento.
 Entre las líneas 
\begin_inset Note Note
status open

\begin_layout Plain Layout
DEFINIR
\end_layout

\end_inset

, se aprecia como se encuentra conformada la sección 
\emph on
definitions.

\emph default
 A su vez, la operación 
\emph on
GET_/pet/{petId}
\emph default
 se detalla desde la línea 
\begin_inset Note Note
status open

\begin_layout Plain Layout
46 hasta la 66
\end_layout

\end_inset

 inclusive.
\end_layout

\begin_layout Standard
Por un lado, 
\emph on
parameters 
\emph default
– línea 
\begin_inset Note Note
status open

\begin_layout Plain Layout
46
\end_layout

\end_inset

 – define la entrada de dicha operación.
 La misma está compuesta por un objeto del tipo entero (
\emph on
integer - int64
\emph default
).
 Por otro lado, el objeto dentro de la clave 
\emph on
200
\emph default
, dentro del objeto 
\emph on
response 
\emph default
– línea 
\begin_inset Note Note
status open

\begin_layout Plain Layout
54
\end_layout

\end_inset

 – es un objeto que encapsula la salida de la operación, cuyo esquema es
 una referencia a 
\emph on
#/definitions/Pet
\emph default
, lo que nos indica que debemos ver la definición en la propiedad 
\emph on
Pet
\emph default
 del objeto 
\emph on
definitions
\emph default
, la misma define sus propiedades en el atributo 
\emph on
properties
\emph default
, compuesto por: un identificador 
\emph on
id
\emph default
, una categoría 
\emph on
category
\emph default
, un nombre 
\emph on
name
\emph default
 y un listado de fotos 
\emph on
photoUrls
\emph default
.
\end_layout

\begin_layout Standard
En la Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Componentes-de-Operacion"

\end_inset

 se observa la especificación de la operación 
\emph on
GET_/pet/{petId} 
\emph default
y se encuadran los distintos componentes resultantes del metamodelo.
\begin_inset Note Note
status open

\begin_layout Plain Layout
agregar texto
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En la Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Componentes-de-Tipos-de-datos"

\end_inset

 se observa la especificación de los distintos tipos de datos disponibles
 en la 
\emph on
interfaz
\emph default
, y se encuadran los distintos mapeos disponibles en el metamodelo.
\begin_inset Note Note
status open

\begin_layout Plain Layout
agregar texto
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En la Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:EjemploVersionInstanciada"

\end_inset

 se muesta el diagrama de objetos que representa la salida (instancia del
 metamodelo) generada por el componente Conversor para el documento swagger
 utilizado como ejemplo.
 Es importante destacar que la estructura de datos utilizada generará una
 sola vez los tipos de datos, y si fuera necesario realizar otra instancia
 de la misma clase, se fija la dirección de memoria mediante un puntero
 a aquella que fue creada por primera vez.
 Esto quiere decir que sólo existirá una instancia por cada tipo definido
 dentro del documento.
 Por ejemplo sólo va a existir una instancia que representa al tipo simple
 
\emph on
string
\emph default
, y cada elemento relacionado con este tendrá una referencia a dicha instancia.
\end_layout

\begin_layout Standard
En el diagrama de objetos de la Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:EjemploVersionInstanciada"

\end_inset

 se puede observar una instancia de la clase 
\emph on
Interface
\emph default
, llamada 
\emph on
PetStore
\emph default
 la cual agrupa las operaciones que ofrece el servicio.
 Recordamos que este servicio cuenta con cuatro operaciones, cada una asociada
 a su respectiva entrada y salida (
\emph on
input
\emph default
/
\emph on
output
\emph default
).
 A su vez cada entrada/salida está relacionada con los parámetros que las
 componen.
 Con el fin de mostrar a manera resumida como queda la instancia del metamodelo,
 solo se detalla la función 
\emph on
GET_/pet/{petId}
\emph default
.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename ImgChapter3/usadas/getPetById-(anotado).png
	width 100col%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Componentes-de-Operacion"

\end_inset

Componentes de Operación
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename ImgChapter3/usadas/getPetByIdDefinitions-(anotado).png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Componentes-de-Tipos-de-datos"

\end_inset

Componentes de Tipos de datos
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ImgChapter3/usadas/OAS vs Metamodelo (instancia).png
	lyxscale 80
	width 100col%
	scaleBeforeRotation

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:EjemploVersionInstanciada"

\end_inset

Ejemplo de metamodelo instanciado para el caso de estudio
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Tipos de datos simple
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Los tipos de datos primitivos en la especificación Swagger se basan en los
 tipos admitidos por la Especificación de esquema JSON (Borrador 00)
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://tools.ietf.org/html/draft-wright-json-schema-00#section-4.2
\end_layout

\end_inset


\end_layout

\end_inset

.
 Null no es compatible como tipo.
 
\end_layout

\begin_layout Standard
Los tipos de datos primitivos tienen una propiedad modificadora opcional:
 
\emph on
format
\emph default
.
 La especificación Swagger utiliza varios formatos conocidos para definir
 en detalle el tipo de datos que se utiliza.
 Sin embargo, para mantener las necesidades de la documentación, la propiedad
 format puede tener cualquier valor.
 Los formatos como "email", "uuid", etc., PUEDEN usarse aunque no estén definidos
 por esta especificación.
 Los tipos que no poseen la propiedad format siguen la definición de tipo
 del esquema JSON.
 Ésta herramienta, al no encontrarse con un format no especificado PUEDE
 utilizar el tipo predeterminado.
\end_layout

\begin_layout Standard
Adicionalmente, un tipo de dato primitivo “file” es usado por el objeto
 Parameter y Response para denotar que el tipo del parámetro o de respuesta
 es un archivo.
 
\end_layout

\begin_layout Standard
Todos los tipos de datos simple soportados por la especificación Swagger
 están incluidos en los tipos de datos definidos por el Metamodelo, como
 se puede observar en el Cuadro 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Correspondencia-Tipos-de-datos"

\end_inset

.
 El mismo contiene cinco columnas, en la columna 
\emph on
Nombre
\emph default
 se puede observar el nombre coloquial que se le da al tipo de dato, las
 columnas 
\emph on
Type
\emph default
 y 
\emph on
Format
\emph default
 son las propiedades que definen el dato en la especificación, y por último
 la columna 
\emph on
SimpleType 
\emph default
indica el 
\emph on
tipo 
\emph default
que se le asigna a la instancia de SimpleType correspondiente.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center

\size scriptsize
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="9text%">
<column alignment="center" valignment="top" width="8text%">
<column alignment="center" valignment="top" width="8.5text%">
<column alignment="center" valignment="top" width="35text%">
<column alignment="center" valignment="top" width="18text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Nombre
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Format
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Comentarios
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
SimpleType
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
int32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
32 bits con signo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
INTEGER
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
long
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
int64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
64 bits con signo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
LONG
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
float
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
number
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
float
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
FLOAT
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
double
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
number
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
double
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
DOUBLE
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
string
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
string
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
STRING
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
byte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
string
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
byte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Caracteres codificados en base64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
BASE64
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
string
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Cualquier secuencia de octales
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
BYTE
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
boolean 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
boolean
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
BOOLEAN
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
date
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
string
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
date
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Como se define full-date en RFC3339
\begin_inset Foot
status open

\begin_layout Plain Layout

\size scriptsize
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://xml2rfc.ietf.org/public/rfc/html/rfc3339.html#anchor14
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
DATE
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
dateTime
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
string
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
date-time
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Como se define date-time en RFC3339
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
DATE_TIME
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
password
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
string 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
password
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Especifica que la UI debe ofuscar el input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
STRING
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
file
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
file
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
BASE64_BINARY
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Correspondencia-Tipos-de-datos"

\end_inset

Correspondencia Tipos de datos Simple con Metamodelo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Construcción-del-instanciador"

\end_inset

Construcción del Conversor
\end_layout

\begin_layout Standard
En los siguientes párrafos se detallan los pasos principales para la construcció
n del Conversor.
 Primeramente fue necesario analizar las herramientas que se encuentran
 disponibles que podrían ser potencialmente útiles a la hora de implementar
 el módulo de software Conversor del Metamodelo.
 Luego se explica en detalle el proceso de conversión de documentos WSDL
 2.0 a instancias del metamodelo junto con los algoritmos involucrados para
 realizar dichas operaciones.
 
\end_layout

\begin_layout Paragraph
\begin_inset CommandInset label
LatexCommand label
name "par:Selección-del-lenguaje"

\end_inset

Selección del lenguaje de programación utilizado
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
El Metamodelo y la herramienta de evaluación de servicio web están realizadas
 en Java, Java es un lenguaje muy popular, pero a veces se suele desperdiciar
 mucho tiempo, o caracteres, en escribir lógica que se podría redactar de
 manera más simple.
 Es por ello, entre otras cosas, que se decidió usar Kotlin, un lenguaje
 que se ejecuta sobre la JVM (Java Virtual Machine) y simplifica el trabajo
 del desarrollador, el cual pasa menos tiempo escribiendo lógica ajena al
 dominio.
 Un aspecto importante que destacar es que Kotlin al compilar a Bytecode
 y correr sobre la JVM, es totalmente interoperable con Java, es decir,
 desde nuestro código Kotlin podemos utilizar clases y métodos Java y viceversa,
 inclusive podemos tener un proyecto mixto, en donde coexistan clases Java
 y Kotlin.
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "ventajas-kotlin"

\end_inset

Entre algunas de las ventajas de Kotlin, se encuentran: 
\end_layout

\begin_layout Itemize
Constructores de clase por defecto, sólo es necesario declarar las variables
 de clase una vez.
\end_layout

\begin_layout Itemize

\emph on
Setters
\emph default
 y 
\emph on
getters
\emph default
 implícitos, es decir, a menos que se desee cambiar el comportamiento de
 los mismos no es necesario escribirlos, además el lenguaje al compilar
 a Bytecode reemplazará los accesos y asignaciones directas a atributos,
 por los llamados a las funciones setter y getter, con lo cual el código
 se vuelve más legible.
\end_layout

\begin_layout Itemize
Tipo de clase 
\emph on
Data
\emph default
, la cual está pensada para almacenar datos, por lo tanto infiere los métodos
 
\emph on
equals
\emph default
,
\emph on
 hashCode
\emph default
, 
\emph on
toString
\emph default
 y 
\emph on
copy
\emph default
 de los atributos.
\end_layout

\begin_layout Standard
Sólo con estas ventajas, logramos que nuestra clase 
\emph on
Case
\emph default
 tenga únicamente 10 lineas de código, cuando su equivalente funcional en
 Java tendría aproximadamente 121, esto representa un 91.73% ménos de código,
 sin contar que es semánticamente mas legible
\begin_inset Note Note
status open

\begin_layout Plain Layout
Comparación de ambos códigos?
\end_layout

\end_inset

.
 Además, a menos que se especifique lo contrario, ninguna variable puede
 tomar el valor null, esto nos previene de NullPointerException inesperados.
\end_layout

\begin_layout Paragraph
\begin_inset CommandInset label
LatexCommand label
name "subsec:Proceso-de-selección"

\end_inset

Selección de herramientas para construcción de módulo de software Conversor
 del Metamodelo
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Tomando como base la explicación detallada en la Sección 
\emph on
YYYYY
\emph default

\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Detalle-de-selección"

\end_inset

, donde se analizaron las herramientas evaluadas para ser utilizadas potencialme
nte por el módulo de software Conversor del Metamodelo, en la presente sección
 se pretende destacar ventajas y desventajas de dichas herramientas.
 En principio, resultó necesario satisfacer la necesidad de parsear una
 especificacón Swagger.
 Para ello se analizaron las herramientas
\emph on
 swagger-parser
\emph default
 y 
\emph on
KaiZen OpenAPI Parser
\emph default
.
 Luego de este análisis, 
\emph on
swagger-parser
\emph default
 resultaró ser el candidatos más apropiados para la construcción del módulo
 de software Conversor.
 
\end_layout

\begin_layout Paragraph
Motivos principales por los cuales no se utilizaron las siguientes herramientas
 
\begin_inset CommandInset label
LatexCommand label
name "par:UtilizacionHerramientasProcSwagger"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Itemize
PONGO UNA LISTA SI DESCARTO UNA SOLA???7
\end_layout

\begin_layout Itemize
KaiZen OpenAPI Parser: Buscar desventajas
\end_layout

\begin_layout Itemize
\begin_inset Note Note
status open

\begin_layout Itemize

\series bold
JWSDL:
\series default
 posee un inconveniente fundamental (éste figura en la documentación y se
 pudo comprobar en la práctica) por el cual no se utilizó esta herramienta
 para manipular documentos WSDL.
 Cualquier hijo de <types> (dentro del documento) es tratado como elemento
 de una extensión que no se encuentra implementada entre sus funciones.
 Debido a esto resulta imposible poder analizar las estructuras de los tipos
 complejos, y por consiguiente las entradas y salidas de las operaciones
 dentro de un documento WSDL.
 En otras palabras, no se utilizó ya que no era posible analizar los datos
 definidos en el 
\emph on
tag
\emph default
 
\emph on
types 
\emph default
de los documentos.
 Además no soporta documentos WSDL 2.0, y la intención es concentrarse en
 las tecnologías más actuales que dispone el mercado.
 
\end_layout

\begin_layout Itemize

\series bold
SOA Membrane
\series default
: cuando se intentó acceder a los atributos, se dificultó el acceso a los
 tipos complejos de datos.
 Esto es porque no se pudo profundizar en su contenido con el detalle necesario
 para el componente de software que se pretendía desarrollar.
 
\end_layout

\begin_layout Itemize

\series bold
EasyWSDL:
\series default
 en la teoría soporta versiones de WSDL 1.1 y 2.0, pero al intentar cargar
 el conjunto de documentos de la plataforma Mashape, un porcentaje no pudo
 ser utilizado porque no eran sintácticamente válidos según el metamodelo
 propuesto por esta herramienta.
 Debido a esto, el proceso de análisis para los documentos afectados no
 pudo continuar.
 Además, el alcance de la herramienta es extenso, coordinar con los mensajes
 de entrada y salida para la creación y/o manipulación de datos lleva un
 proceso de aprendizaje muy grande.
 Por estas razones se decidió no utilizar esta herramienta.
 
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
\begin_inset CommandInset label
LatexCommand label
name "par:Herramientas-util-instanciador"

\end_inset

Herramientas utilizadas en el Conversor
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Para la creación del módulo de software Conversor, se utilizó una herramienta
 que fué de principal relevancia a la hora de poder concretar la creación
 de dicho módulo.
 Swagger-parser permitió parsear una especificación Swagger en instancias
 de Objeto Plano de Java (POJO).
 Utilizando esta herramienta, en lugar de leer y acceder de manera directa
 a los archivos, podemos ignorar la disposición de los distintos componentes
 en el mismo y concentrarnos en el mapeo Swagger-SOAML.
 Como así también, tener la posibilidad de utilizar una especificación Swagger
 en archivo YAML o JSON sin tener que realizar ningún refactoring adicional.
 Otra ventaja que nos brinda ésta herramienta, es la validación a nivel
 sintáctico de las especificaciones.
\end_layout

\begin_layout Itemize
\begin_inset Note Note
status open

\begin_layout Itemize

\series bold
WODEN:
\series default
 utilizada para validar que los documentos WSDL utilizados como entrada
 al Conversor del metamodelo estuvieran bien formados.
 Esto quiere decir que con WODEN se validó que los documentos utilicen las
 etiquetas (tags) definidas por la W3C para documentos WSDL, que haya correspond
encia entre mensajes, la definición de los mismos, etc.
 De esta manera, a la hora de testear la Herramienta de Evaluación de Servicios
 Web, se trabajó con documentos bien formados desde un principio.
 Además esta herramienta permitió poder trabajar con documentos WSDL versión
 1.1.
 Básicamente si se necesita trabajar con documentos WSDL 1.1, se utiliza
 una función que convierte documentos de la versión WSDL 1.1 a la versión
 de WSDL 2.0 para luego si procesarlo como entrada al componente Conversor
 del metamodelo.
 Como un ejemplo, en el Capítulo
\begin_inset space ~
\end_inset

 4, se pudo experimentar con un conjunto de 1146 archivos WSDL versión 1.1
 de Servicios Web reales que provienen de la plataforma Mashape
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://mashape.com
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
DOM: 
\series default
acorde con DOM, cualquier elemento perteneciente al proyecto de un documento
 XML es un nodo.
 De esta manera se pudo acceder a todos los detalles específicos dentro
 de un documento WSDL sin ningún tipo de restricción.
 Esta librería es una de las herramientas más usadas y populares a la hora
 de manipular documentos XML.
 En el presente trabajo se hizo énfasis en las estructuras del documento
 relevantes para el módulo de software Conversor del Metamodelo.
 Por esta razón, se prestó especial atención a la sección 
\emph on
types
\emph default
 e 
\emph on
interface
\emph default
 que son parte de los elementos que conforman un WSDL 2.0 bien formado.
 Para esto resultó especialmente útil contar con una herramienta que permitiera
 recorrer y analizar un documento WSDL de forma confiable y robusta, sin
 nigun tipo de restricción, es decir, permitiendo el acceso a la totalidad
 del documento.
 DOM cumple con las características necesarias para llevar adelante el objetivo
 de construir un instanciador automático.
 Además, DOM nos permite gracias a una de sus funciones de navegación en
 el código fuente, analizar si el documento está bien formado, es decir
 que no tenga errores sintácticos.
 
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Consideraciones generales
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Se consideran las especificaciones Swagger a parsear como válidas, es decir,
 al parsear el Swagger al Metamodelo, no garantizamos la validación de la
 api, por ejemplo, en la documentación de Swagger
\begin_inset CommandInset citation
LatexCommand cite
key "swagger2.0"

\end_inset

 se indica:
\end_layout

\begin_layout Quotation
El objeto Response 
\emph on
DEBE
\emph default
 contener al menos algún código de respuesta, y 
\emph on
DEBERÍA
\emph default
 ser la respuesta del llamado de una operación exitosa.
\end_layout

\begin_layout Standard
Por lo tanto, si esta condición no se respeta y se utiliza la herramienta
 en cuestión, se pueden obtener resultados inesperados.
 Esto simplifica la herramienta y ayuda a una generar una abstracción de
 capas.
 
\end_layout

\begin_layout Standard
Los códigos de estado HTTP son utilizados para indicar el estado de la operación
 realizada.
 
\end_layout

\begin_layout Standard
Los códigos de estado disponibles están definidos por 
\emph on
RFC7231
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://tools.ietf.org/ html/rfc7231#section-6
\end_layout

\end_inset


\end_layout

\end_inset

 y los códigos de estado registrados se enumeran en el Registro de códigos
 de estado de la 
\emph on
IANA
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.iana.org/ assignments/http-status-codes/http-status-codes.xhtml
\end_layout

\end_inset


\end_layout

\end_inset

, siguiendo las siguientes convenciones:
\end_layout

\begin_layout Itemize
1xx (Informacional): El request fue recibido, se continúa procesando.
\end_layout

\begin_layout Itemize
2xx (Exitoso): El request fue exitosamente recibido, entendido y aceptado.
\end_layout

\begin_layout Itemize
3xx (Redirección): Se deben tomar medidas adicionales para completar la
 solicitud.
\end_layout

\begin_layout Itemize
4xx (Error del cliente): el request contiene mala sintaxis o no se puede
 cumplir.
\end_layout

\begin_layout Itemize
5xx (Error del servidor): El servidor no cumplió con una solicitud aparentemente
 válida.
\end_layout

\begin_layout Standard
De acuerdo a la especificación Swagger, los archivos que su descripción
 se representan como objetos JSON, y cumplen con los estándatares JSON.
 YAML, al ser un superconjunto de JSON, también puede ser utilizado para
 representar una especificación Swagger.
 
\end_layout

\begin_layout Standard
Todos los nombres en la especificación son sensibles a mayúsculas y minúsculas.
 
\end_layout

\begin_layout Standard
El esquema expone dos tipos de campos: Campos fijos, que tienen un nombre
 declarado, y Campos modelados, que declaran un patrón de expresiones regulares
 para el nombre del campo.
 Los campos modelados DEBEN tener nombres únicos dentro del objeto contenedor.
 Para preservar la compatibilidad de ida y vuelta entre los formatos YAML
 y JSON, se recomienda la versión 1.2 de YAML junto con algunas restricciones
 adicionales: 
\end_layout

\begin_layout Itemize
Las etiquetas DEBEN estar limitadas a aquellas permitidas por el conjunto
 de reglas de esquema JSON
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.yaml.org/spec/1.2/spec.html#id2803231
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
Las claves utilizadas en los diccionarios YAML DEBEN estar limitadas a una
 cadena escalar, según lo definido por el conjunto de reglas de esquema
 a prueba de fallas YAML
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://yaml.org/spec/1.2/spec.html#id2802346
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Si bien las API pueden ser definidas por documentos Swagger en formato YAML
 o JSON, no es requerido que las API en cuestión se limite a utilizar estos
 formatos, es decir, el body del request y response de dicha API y otros
 contenidos no requieren ser JSON o YAML.
\end_layout

\begin_layout Paragraph
Conversión de especificaciones Swagger a instancias del metamodelo
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
El Conversor desarrollado recibe como entrada una especificación Swagger
 (específicamente el 
\emph on
path 
\emph default
o URL de la misma) y devuelve como salida una instancia del metamodelo.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Los elementos de la especificación son vistos como nodos, y cada nodo se
 encuentra en un determinado nivel en la estructura de arbol, siendo N
\begin_inset script subscript

\begin_layout Plain Layout
0
\end_layout

\end_inset

 el nivel inicial, y cada vez que se desciende un nivel, el subíndice de
 N aumenta en 1 unidad.
 El nodo 
\emph on
document
\emph default
, es el nodo padre y se encuentra en el nivel N
\begin_inset script subscript

\begin_layout Plain Layout
0
\end_layout

\end_inset

.
 En el nivel N
\begin_inset script subscript

\begin_layout Plain Layout
1 
\end_layout

\end_inset

se encuentran los nodos 
\emph on
interface 
\emph default
y 
\emph on
types.

\emph default
 En 
\emph on
types 
\emph default
se definen todos los tipos de datos existentes en el documento.
 En 
\emph on
interface 
\emph default
se encuentran detalladas las operaciones (
\emph on
operation
\emph default
) que ofrece el servicio (N
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

).
 En el nivel N
\begin_inset script subscript

\begin_layout Plain Layout
3
\end_layout

\end_inset

 tenemos los mensajes de entrada (
\emph on
input
\emph default
) y de salida (
\emph on
output
\emph default
).
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Siguiendo nuestro ejemplo de base del dominio PetStore, la Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Ejemplo-versión-Dom-1"

\end_inset

 muestra un esquema de como quedaría la estructura con los distintos atributos
 que conforman una especificación Swagger al parsearla con la herramienta
 Swagger-parser.
 Cabe destacar que en esta figura, solo se detalla la operación 
\emph on
GET_/pet/{petId}
\emph default
, con el objetivo de dar un ejemplo gráfico de fácil comprensión.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ImgChapter3/usadas/UML OAS.png
	width 100text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Ejemplo-versión-Dom-1"

\end_inset

Ejemplo de objetos que se analizan del documento WSDL parseado con la herramient
a DOM
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
REEMPLAZAR NUMEROS DE LINEA
\end_layout

\end_inset

A continuación se detalla el pseudocódigo del módulo de software de conversión
 de especificaciones Swagger a instancias del metamodelo.
 En el Algoritmo
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Convertir-especificación-Open"

\end_inset

 la función propuesta recibe como entrada una especificación Swagger – línea
 1.
 El primer paso es parsearlo a un objeto que posee la estructura de la especific
ación Swagger – línea 2.
 Luego por cada operación (método HTTP) que tenga cada 
\emph on
path, 
\emph default
crearemos una operación del metamodelo - línea 32, con los atributos 
\emph on
input
\emph default
, 
\emph on
output
\emph default
 y 
\emph on
faults 
\emph default
obtenidos previamente.
 Por cada 
\emph on
parameter 
\emph default
de la operación crearemos un metamodelParameter obteniendo el tipo de dato
 según el procedimiento detallado en el Algotirmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Convertir-especificación-Open"

\end_inset

, con éstos parametros crearemos nuestro input.
\end_layout

\begin_layout Standard
Cada response de la operación se analiza, ya que la misma puede ser una
 respuesta exitosa o fallida.
 En caso de ser la primera, es facil evidenciarlo, pues el 
\emph on
status code 
\emph default
de la misma comenzará con 
\emph on
2
\emph default
, si la respuesta tiene tipo se creará un parametro que luego será usado
 con el 
\emph on
output
\emph default
 - línea 22.
 En caso de ser la segunda opción, se crea un nuevo 
\emph on
Fault 
\emph default
con el tipo de la respuesta, y se agregará a la lista de 
\emph on
faults
\emph default
 - línea 26.
\end_layout

\begin_layout Standard
Una vez terminado de recorrer las operaciones de cada 
\emph on
path,
\emph default
 se crea la interfaz del metamodelo con el listado de operaciones.
 Finalmente es retornada una instancia del metamodelo generado a partir
 de la especificación Swagger utilizada como entrada.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "numbers=left,numberstyle={\scriptsize},basicstyle={\scriptsize\ttfamily},breaklines=true,showstringspaces=false,numberstyle={\ttfamily\scriptsize}"
inline false
status open

\begin_layout Plain Layout

function convertir_Swagger_A_Metamodelo(String SwaggerSpecPath){
\end_layout

\begin_layout Plain Layout

 Swagger swaggerSpec = SwaggerParser().read(SwaggerSpecPath)
\end_layout

\begin_layout Plain Layout

 List<Operation> operations = []
\end_layout

\begin_layout Plain Layout

 for(path: swaggerSpec.paths){
\end_layout

\begin_layout Plain Layout

  for(operation: path.methods){
\end_layout

\begin_layout Plain Layout

   List<Parameter> parameters = []
\end_layout

\begin_layout Plain Layout

   for(parameter: operation.parameters){
\end_layout

\begin_layout Plain Layout

    Type parameterType = obtenerTipoDeDatoParameter(parameter, swaggerSpec)
\end_layout

\begin_layout Plain Layout

    Parameter metamodelParameter = 'Crear Parameter con parameter.name y
 parameterType'
\end_layout

\begin_layout Plain Layout

    parameters.add(metamodelParameter)
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

   Input input = 'Crear Input con parameters';
\end_layout

\begin_layout Plain Layout

   Output output = null
\end_layout

\begin_layout Plain Layout

   List<Fault> faults = []
\end_layout

\begin_layout Plain Layout

   for(response in operation.reponses){
\end_layout

\begin_layout Plain Layout

    Type responseType = obtenerTipoDeDatoParameter(response.value.responseSchema,
 swaggerSpec)
\end_layout

\begin_layout Plain Layout

    if(response.statusCode.startsWith("2")){
\end_layout

\begin_layout Plain Layout

     List<Parameter> outputParameters = []
\end_layout

\begin_layout Plain Layout

     if(responseType != null){
\end_layout

\begin_layout Plain Layout

      Parameter outputParameter = 'Crear outputParameter con tipo responseType'
\end_layout

\begin_layout Plain Layout

      outputParameters.add(outputParameter)
\end_layout

\begin_layout Plain Layout

     }
\end_layout

\begin_layout Plain Layout

     output = 'Crear output con outputParameters'
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else{
\end_layout

\begin_layout Plain Layout

     Fault fault = "Crear fault con tipo responseType"
\end_layout

\begin_layout Plain Layout

     faults.add(fault)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

   Operation metamodelOperation = 'Crear operacion con input, output y faults'
\end_layout

\begin_layout Plain Layout

   operations.add(metamodelOperation)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

 Interface metamodelInterface = 'Crear interface con operations'
\end_layout

\begin_layout Plain Layout

 return metamodelInterface
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Convertir-especificación-Open"

\end_inset

Convertir especificación Swagger a Metamodelo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
\begin_inset Note Note
status collapsed

\begin_layout Paragraph
old
\end_layout

\begin_layout Plain Layout
Para evaluar los tipos de datos nos basamos principalmente en los Algoritmos
 
\begin_inset CommandInset ref
LatexCommand ref
reference "Obtener tipo de dato"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "Es tipo complejo"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "Es tipo simple"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "Obtener nombre tipo simple"

\end_inset

, donde en el primero se encuentra la lógica principal, y los restantes
 describen las funciones auxiliares.
 Los mismos cumplen la función de discriminar la estructura sintáctica de
 los programas involucrados.
 Dado un nodo como entrada a la función del primero, el análisis retorna
 si se tiene tipos de datos simples, complejos o arreglos.
\end_layout

\begin_layout Plain Layout
En los dos párrafos siguientes se explicará brevemente el funcionamiento
 del Algoritmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "Obtener tipo de dato"

\end_inset

.
 En la línea 3, se verifica si el nodo es de tipo simple, en cuyo caso se
 crea el objeto de tipo simple con sus respectivos datos.
 Luego, se analiza en la línea 5, si estamos ante la presencia de un tipo
 de dato arreglo, para lo cual consultamos sobre un atributo llamado 
\emph on
unbounded
\emph default
.
 En caso de no ser 
\emph on
unbounded
\emph default
, se retorna el tipo simple que se creó en la línea 4.
 Caso contrario, nos encontramos ante un tipo de dato arreglo (
\emph on
ArrayType
\emph default
), el cual contendrá al tipo simple previamente mencionado, siendo una colección
 de tipos simples.
 
\end_layout

\begin_layout Plain Layout
Ahora bien, si tenemos un tipo de dato complejo
\emph on
 – ComplexType
\emph default
 (línea 13) –, debemos indagar en su estructura interna, puesto que puede
 estar compuesto por más tipos de datos complejos, arreglos o tipos simples.
 Mediante llamados recursivos se construirá la estructura del tipo de dato
 complejo.
 Una vez que creamos el tipo de dato complejo, resta preguntar si el mismo
 se encuentra contenido en una estructura de arreglo, lo que nos llevará
 en caso afirmativo a crear un arreglo asociado al tipo complejo recientemente
 creado y retornarlo; caso contrario retornamos el tipo complejo previamente
 instanciado.
 
\end_layout

\begin_layout Plain Layout
Para saber si estamos ante la presencia de un tipo de dato complejo se creó
 la función 
\emph on
esTipoComplejo(Nodo nodo)
\emph default
 (Algoritmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "Es tipo complejo"

\end_inset

), en la cual se obtiene los hijos del 
\emph on
nodo 
\emph default
que entra por parámetro de la función , en caso de que por lo menos tenga
 uno, y el nombre del mismo contenga la palabra compuesta 
\emph on
ComplexType
\emph default
 estamos en presencia de un tipo de dato complejo.
 Para saber si tenemos un tipo de dato simple recurrimos a la función 
\emph on
esTipoSimple(Nodo nodo) 
\emph default
(Algoritmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "Es tipo simple"

\end_inset

).
 Se obtiene el atributo 
\emph on
type
\emph default
 del 
\emph on
nodo
\emph default
 y si coincide con algún tipo de dato simple de los definidos en la Sección
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Vision-Detallada"

\end_inset

 
\emph on
SimpleType
\emph default
, entonces efectivamente es un tipo simple.
 Por último tenemos la función 
\emph on
obtenerNombreTipoSimple(Nodo nodo) 
\emph default
(Algoritmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "Obtener nombre tipo simple"

\end_inset

) que retorna el nombre de un tipo de dato simple.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "numbers=left,basicstyle={\scriptsize\ttfamily},breaklines=true,numberstyle={\ttfamily\scriptsize}"
inline false
status open

\begin_layout Plain Layout

function Type obtenerTipoDeDatoParameter(Parameter parameter, Swagger swaggerSpe
c) {
\end_layout

\begin_layout Plain Layout

 if(parameter.isInstanceOf(HeaderParameter | QueryParameter | PathParameter)){
\end_layout

\begin_layout Plain Layout

  SimpleType type = obtenerTipoSimple(parameter.type, parameter.format, null,
 parameter.items, swaggerSpec)
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

 else if(parameter.isInstanceOf(BodyParameter)){
\end_layout

\begin_layout Plain Layout

  Schema schema = parameter.schema
\end_layout

\begin_layout Plain Layout

  if(schema.isInstanceOf(ModelImpl)){
\end_layout

\begin_layout Plain Layout

   SimpleType type = obtenerTipoSimple(schema.type, schema.format, schema,
 null, swaggerSpec)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  else if(schema.isInstanceOf(ArrayModel)){
\end_layout

\begin_layout Plain Layout

   Type arrayType = obtenerTipo(schema.items, swaggerSpec)
\end_layout

\begin_layout Plain Layout

   ArrayType type = 'Crear type con arrayType'
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  else if(schema.isInstanceOf(RefModel)){
\end_layout

\begin_layout Plain Layout

   ComplexType type = obtenerTipoComplejo(schema.simpleRef, swaggerSpec)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  else if(schema is Null){
\end_layout

\begin_layout Plain Layout

   type = null
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

 return type
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Obtener tipo de parameter"

\end_inset

Obtener tipo de parameter
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "numbers=left,basicstyle={\scriptsize\ttfamily},breaklines=true,numberstyle={\ttfamily\scriptsize}"
inline false
status open

\begin_layout Plain Layout

function Type obtenerTipo(Property property, Swagger swaggerSpec) {
\end_layout

\begin_layout Plain Layout

 if(property.isInstanceOf(ArrayProperty){
\end_layout

\begin_layout Plain Layout

  Type arrayType = obtenerTipo(property.items, swaggerSpec)
\end_layout

\begin_layout Plain Layout

  ArrayType type = 'Crear type con arrayType'
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

 else if(property.isInstanceOf(ObjectProperty)){
\end_layout

\begin_layout Plain Layout

  List<Attribute> attributes = []
\end_layout

\begin_layout Plain Layout

  for(property in property.properties){
\end_layout

\begin_layout Plain Layout

   Type type = obtenerTipo(property.value, swaggerSpec)
\end_layout

\begin_layout Plain Layout

   Attribute attribute = Attribute(property.key, type)
\end_layout

\begin_layout Plain Layout

   attributes.add(attribute)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  ComplexType type = 'Crear type con property.name y attributes'
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

 else if(property.isInstanceOf(MapProperty)){
\end_layout

\begin_layout Plain Layout

  Property additionalProperties = property.additionalProperties
\end_layout

\begin_layout Plain Layout

  Type additionalPropertyType = obtenerTipo(additionalProperties, swaggerSpec)
\end_layout

\begin_layout Plain Layout

  Attribute attribute = Attribute(additionalProperties.title, additionalPropertyT
ype)
\end_layout

\begin_layout Plain Layout

  ComplexType type = 'Crear type con property.name y attribute'
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

 else if(property.isInstanceOf(RefProperty){
\end_layout

\begin_layout Plain Layout

  ComplexType type = obtenerTipoComplejo(property.simpleRef, swaggerSpec)
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

 else{
\end_layout

\begin_layout Plain Layout

  SimpleType type =  obtenerTipoSimple(property.type, property.format, null,
 null, swaggerSpec)
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

 return type
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Obtener tipo"

\end_inset

Obtener tipo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "numbers=left,basicstyle={\scriptsize\ttfamily},breaklines=true,numberstyle={\ttfamily\scriptsize}"
inline false
status open

\begin_layout Plain Layout

function Type obtenerTipoComplejo(String name, Swagger swaggerSpec) {
\end_layout

\begin_layout Plain Layout

 List<Attribute> attributes = []
\end_layout

\begin_layout Plain Layout

 Schema schema = swaggerSpec.definitions[name]
\end_layout

\begin_layout Plain Layout

 for(property in schema.properties){
\end_layout

\begin_layout Plain Layout

  Type type = obtenerTipo(property.value, swaggerSpec)
\end_layout

\begin_layout Plain Layout

  Attribute attribute = Attribute(property.key, type)
\end_layout

\begin_layout Plain Layout

  attributes.add(attribute)
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

 Property additionalProperties = schema.additionalProperties
\end_layout

\begin_layout Plain Layout

 if(schema.isInstanceOf(ModelImpl) && additionalProperties != null) {
\end_layout

\begin_layout Plain Layout

  Type additionalPropertyType = obtenerTipo(additionalProperties, swaggerSpec)
\end_layout

\begin_layout Plain Layout

  Attribute attribute = Attribute(additionalProperties.title, additionalPropertyT
ype)
\end_layout

\begin_layout Plain Layout

  attributes.add(attribute)
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

 ComplexType type = 'Crear type con property.name y attribute'
\end_layout

\begin_layout Plain Layout

 return type
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Obtener tipo complejo"

\end_inset

Obtener tipo complejo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "numbers=left,basicstyle={\scriptsize\ttfamily},breaklines=true,numberstyle={\ttfamily\scriptsize}"
inline false
status open

\begin_layout Plain Layout

function Type obtenerTipoSimple(String typeName, String format, ModelImpl
 schema, Property properties, Swagger swaggerSpec) {
\end_layout

\begin_layout Plain Layout

 if(typeName=="integer"){
\end_layout

\begin_layout Plain Layout

  if(format=="int64"){
\end_layout

\begin_layout Plain Layout

   SimpleType simpleType = SimpleType(SimpleType.LONG)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  else{
\end_layout

\begin_layout Plain Layout

   SimpleType simpleType = SimpleType(SimpleType.INTEGER)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

 else if(typeName=="number"){
\end_layout

\begin_layout Plain Layout

  if(format=="double"){
\end_layout

\begin_layout Plain Layout

   SimpleType simpleType = SimpleType(SimpleType.DOUBLE)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  else{
\end_layout

\begin_layout Plain Layout

   SimpleType simpleType = SimpleType(SimpleType.FLOAT)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

 else if(typeName=="boolean"){
\end_layout

\begin_layout Plain Layout

  SimpleType simpleType = SimpleType(SimpleType.BOOLEAN)
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

 else if(typeName=="string"){
\end_layout

\begin_layout Plain Layout

  if(format=="byte" || format=="base64""){
\end_layout

\begin_layout Plain Layout

   SimpleType simpleType = SimpleType(SimpleType.BASE64)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  else if(format=="binary"){
\end_layout

\begin_layout Plain Layout

   SimpleType simpleType = SimpleType(SimpleType.BYTE)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  else if(format=="date"){
\end_layout

\begin_layout Plain Layout

   SimpleType simpleType = SimpleType(SimpleType.DATE)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  else if(format=="date-time"){
\end_layout

\begin_layout Plain Layout

   SimpleType simpleType = SimpleType(SimpleType.DATE_TIME)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  else{
\end_layout

\begin_layout Plain Layout

   SimpleType simpleType = SimpleType(SimpleType.STRING)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

 else if(typeName=="file"){
\end_layout

\begin_layout Plain Layout

  SimpleType simpleType = SimpleType(SimpleType.BASE64_BINARY)
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

 else if(typeName=="object"){
\end_layout

\begin_layout Plain Layout

  List<Attribute> attributes = []
\end_layout

\begin_layout Plain Layout

  for(property in schema.properties){
\end_layout

\begin_layout Plain Layout

   Type propertyType = obtenerTipo(property.value, swaggerSpec)
\end_layout

\begin_layout Plain Layout

   Attribute attribute = Attribute(property.key, propertyType)
\end_layout

\begin_layout Plain Layout

   attributes.add(attribute)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  ComplexType type = 'Crear type con schema.name y attributes'
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

 else if(typeNamee=="array"){
\end_layout

\begin_layout Plain Layout

  Type arrayType = obtenerTipo(properties, swaggerSpec)
\end_layout

\begin_layout Plain Layout

  ArrayType type = ArrayType(arrayType)
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

 return type
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Obtener tipo simple"

\end_inset

Obtener tipo simple
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Intregracion-a-Testooj"

\end_inset

Integración a la Herramienta de Evaluación de Servicios Web 
\end_layout

\begin_layout Standard

\noun on
ÉSTA SECCIÓN NO VA!!!
\noun default
!
\begin_inset Note Note
status open

\begin_layout Plain Layout
Esta sección no va
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El objetivo principal del desarrollo del Metamodelo para descripción de
 Contratos de Servicios Web es contar con una especificación de la funcionalidad
 que ofrece cada servicio (independientemente de la tecnología en la cual
 esté implementado).
 Al contar con dicho metamodelo resulta necesario que la evaluación de servicios
 candidatos se realice en función de instanciaciones del metamodelo.
 Para ello, se desarrolló un componente de software que contiene al metamodelo.
 En el nuevo enfoque, tanto los requerimientos funcionales por parte de
 desarrolladores de aplicaciones orientadas a servicios, como los propios
 servicios candidatos, serán representados y comparados mediante instanciaciones
 del metamodelo desarrollado.
 
\end_layout

\begin_layout Subsection
Proceso de selección y descubrimiento modificado
\end_layout

\begin_layout Standard
En la Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Esquema-propuesto"

\end_inset

 se presenta de manera esquemática la modificación sobre el proceso de descubrim
iento y selección de Servicios Web, al considerar los dos nuevos componentes
 (metamodelo y conversor), que son parte de la nueva Herramienta de Evaluación
 de Servicios Web.
 El nuevo proceso consiste inicialmente en generar instancias del metamodelo
 propuesto a partir de los documentos WSDL correspondientes a los Servicios
 Web candidatos.
 En el Paso 1.1 se generan las instancias del metamodelo que corresponden
 al requerimiento funcional del servicio que se espera consumir por la aplicació
n – que ahora denominamos 
\begin_inset Formula $I_{C}$
\end_inset

 (Interfaz a Consumir), en vez de 
\begin_inset Formula $I_{R}$
\end_inset

 – a partir de la cual se generan consultas (
\emph on
queries
\emph default
).
 Luego en el Paso 1.2 se realizan las consultas en el registro de descubrimiento
 (tal como el de EasySOC), para obtener los documentos WSDL de los servicios
 del Proveedor, que pueden corresponder a versiones 1.1 y 2.0.
 Con estos documentos, se generan las instancias del metamodelo – que ahora
 denominamos 
\begin_inset Formula $I_{P}$
\end_inset

 (Interfaz Provista), en vez de 
\begin_inset Formula $I_{S}$
\end_inset

 – utilizando el componente Conversor para obtener el conjunto que servirá
 de entrada al Paso 2, que es la selección del servicio candidato más apto.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ImgChapter3/EsquemaMetodoNuevo.png
	width 100col%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Esquema-propuesto"

\end_inset

Modificación del Proceso de Descubrimiento y Selección de Servicios Web
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
En el procedimiento de Análisis de Compatibilidad de Interfaces, que es
 parte del Método de Selección de Servicios Web (Paso 2), se realizó una
 actualización con respecto al componente del Metamodelo.
 En la presente versión (Figura
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Análisis-de-Compatibilidad-Interfcaes"

\end_inset

), se cuentan con las instancias del metamodelo, mediante el ingreso de
 los objetos 
\begin_inset Formula $I_{P}$
\end_inset

 e 
\begin_inset Formula $I_{C}$
\end_inset

, por lo que se puede acceder a todos sus atributos en una forma directa
 para el proceso de obtención de datos de signatura y evaluación tanto semántica
 como estructural.
 Si bien en la versión anterior ilustrada en la Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Análisis-de-Compatibilidad"

\end_inset

, desde los archivos WSDL versión 1.1 se extraían los elementos de signatura,
 ingresaban las clases 
\begin_inset Formula $I_{S}$
\end_inset

 e 
\begin_inset Formula $I_{R}$
\end_inset

 y actualmente 
\begin_inset Formula $I_{P}$
\end_inset

 e 
\begin_inset Formula $I_{C}$
\end_inset

, las herramientas de soporte son las mismas: WordNet y el listado de Stop
 words.
 
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ImgChapter3/Análisis-de-Compatibilidad-Interfaces.png
	lyxscale 50
	width 98text%

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Análisis-de-Compatibilidad-Interfcaes"

\end_inset

Análisis de Compatibilidad de Interfaces
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Al realizar la integración del componente del metamodelo se adaptaron las
 estrategias subyacentes para la evaluación de servicios desde el punto
 de vista estructural y semántico presentadas en la Sección
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Compatibilidad-InterfacesOld"

\end_inset

 (Capítulo
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "cap:SOApp"

\end_inset

).
 Para ello se estableció una correspondencia entre los elementos del metamodelo
 definido y las interfaces Java utilizadas en el enfoque anterior.
\end_layout

\begin_layout Subsection
Ventajas sobre implementacion anterior 
\end_layout

\begin_layout Standard
En las versiones anteriores de la plataforma para selección de Servicios
 Web
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "DeRenzis13,castro16"

\end_inset

, la evaluación a nivel de contratos se realizaba analizando interfaces
 Java generadas a partir de documentos WSDL.
 Como se mencionó en la Sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:introMotivacion"

\end_inset

, cada proveedor de servicios utiliza diferentes versiones de WSDL para
 describir las interfaces de sus servicios.
 A la hora de evaluar Servicios Web descritos mediante archivos WSDL, era
 necesario contar con herramientas externas, para cada servicio, generar
 las clases Java en archivos separados porque se utilizaba la herramienta
 Java Reflection
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.oracle.com/technetwork/articles/java/javareflection-1536171.html
 
\end_layout

\end_inset

 como soporte para el análisis.
 Java Reflection es un mecanismo poderoso que provee el lenguaje de programación
 Java (que no existe en otros lenguajes, tal como Pascal, C o C++) el cual
 permite al programa examinarse a sí mismo (introspección), y manipular
 propiedades internas.
 Se utilizaba para acceder y explorar los archivos Java compilados (.class)
 y extraer la información de cada interfaz.
 Junto a Java Reflection, se utilizaba Paranamer
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/paul-hammant/paranamer
\end_layout

\end_inset

, cuya función era permitir obtener el acceso a los nombres de los parámetros
 de los métodos no privados y constructores en tiempo de ejecución.
 Normalmente esta información se pierde en el proceso de compilación.
 
\end_layout

\begin_layout Standard
Con la implementación actual sólo es necesario disponer de las instanciaciones
 del metamodelo sin la necesidad de que existan archivos vinculados entre
 sí.
 Esa es una importante diferencia con respecto a una herramienta externa
 para el procesamiento de WSDL como podría ser EasyWSDL, puesto que para
 cada Servicio Web se generarían los siguientes archivos Java: 
\end_layout

\begin_layout Itemize
Un archivo que incluye la definición de todas las operaciones, el cual represent
a a la clase utilizada para invocar al servicio.
\end_layout

\begin_layout Itemize
Dos archivos Java por cada operación en el servicio.
 Uno de los archivos representa un tipo complejo que encapsula las entradas
 de la operación y el otro archivo representa otro tipo de dato complejo
 que encapsula las salidas de la operación.
 
\end_layout

\begin_layout Itemize
Un archivo Java por cada tipo de dato complejo propio del dominio específico
 del servicio.
 
\end_layout

\begin_layout Standard
Además, el metamodelo propuesto ofrece mas información 
\begin_inset Quotes eld
\end_inset

semántica
\begin_inset Quotes erd
\end_inset

 correspondiente al servicio.
 Un claro ejemplo se ve en la representación de las salidas de una operación.
 En el metamodelo propuesto, la salida de una operación (output) esta compuesta
 por un nombre, que puede ser cualquier tipo de identificador que represente
 a la salida de la operación y un conjunto de parámetros que determina cada
 uno de los datos que son retornados por la operación del servicio.
 En la versión anterior de la herramienta, utilizando interfaces Java, las
 operaciones cuentan simplemente con un tipo de retorno, y en el caso de
 que la operación retorne distintos elementos, se deberá encapsular cada
 uno de ellos, aún cuando en conjunto no conformen una entidad única y distintiv
a del dominio.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "Biblio_Lic"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
