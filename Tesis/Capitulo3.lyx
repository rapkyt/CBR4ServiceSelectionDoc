#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass myBook
\begin_preamble
\usepackage{url}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language spanish
\language_package babel
\inputencoding auto
\fontencoding default
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 0
\use_package cancel 0
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes true
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\author -746951894 "Tincho"
\end_header

\begin_body

\begin_layout Chapter
Proposal
\begin_inset CommandInset label
LatexCommand label
name "chap:Proposal"

\end_inset


\end_layout

\begin_layout Section
Introducción
\end_layout

\begin_layout Standard
Como se mencionó en la Sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Solución-propuesta"

\end_inset

 (Capítulo 1), el objetivo principal de este trabajo es mejorar el Método
 de Selección de Servicios Web presentado en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:SelectionMethodOld"

\end_inset

 (Capítulo
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "cap:SOApp"

\end_inset

).
 En este contexto, uno de los desafíos más importantes a la hora de evaluar
 Servicios Web, es contar con una especificación de contratos de servicios
 que sea lo suficientemente descriptiva en cuanto a las funcionalidades
 que ofrece cada Servicio Web.
 Para lidiar con este desafío, se propuso definir y desarrollar una especificaci
ón de contratos de Servicios Web, que sea independiente de cualquier tecnología
 de implementación.
 Algunas soluciones para problemas similares
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "garriga2015web"

\end_inset

 se basan en estándares existentes como WSDL
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "d2006model"

\end_inset

, o bien proponen especificaciones ad-hoc
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "narayanan2002simulation,chan2008dynamic"

\end_inset

.
\end_layout

\begin_layout Standard
Con el fin de satisfacer el objetivo mencionado, el Metamodelo de descripciones
 de Servicios Web heterogéneos fue extendido, incorporándolo en una nueva
 estructura llamada 
\begin_inset Quotes eld
\end_inset

Caso
\begin_inset Quotes erd
\end_inset

 y un nuevo componente Conversor de especificaciónes Swagger (OAS) hacia
 instancia del 
\begin_inset Quotes eld
\end_inset

Caso
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
El resto del capítulo se distribuye de la siguiente manera: en la Sección
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:CBR-para-selección"

\end_inset

 se presenta el trabajo que se llevó a cabo para poder utilizar el Metamodelo
 para Descripción de Servicios Web dentro del CBR.
 En la Sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:-Conversor de OAS"

\end_inset

 se detalla el Componente Conversor de OAS para instanciar el Metamodelo
 de Servicios Web.
 Finalmente, en la Sección
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Intregracion-a-Testooj"

\end_inset

 
\change_inserted -746951894 1534196044

\end_layout

\begin_layout Section

\change_inserted -746951894 1534196085
Ejemplo Ilustrativo
\end_layout

\begin_layout Standard

\change_inserted -746951894 1534196086
\begin_inset Note Note
status open

\begin_layout Plain Layout

\change_inserted -746951894 1534196087
To Do
\change_unchanged

\end_layout

\end_inset


\change_unchanged

\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:CBR-para-selección"

\end_inset

Razonamiento Basado en Casos para selección de Servicios Web
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Como se mencionó en la Sección
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:SelectionMethodOld"

\end_inset

 (Capítulo 2), anteriormente el Método de Selección de Servicios Web tomaba
 como entrada interfaces Java generadas a partir de documentos WSDL.
 Cuando estas interfaces se generan, por ejemplo, mediante la utilización
 de herramientas como EasyWSDL
\begin_inset Foot
status open

\begin_layout Plain Layout
http://easywsdl.com/
\end_layout

\end_inset

, se pueden observar diversos inconvenientes y limitaciones.
 Como se explicó en el Capítulo 1, existen diversas versiones de WSDL que
 los proveedores de servicios utilizan y esto dificulta generalizar los
 procedimientos para parsear y explorar documentos WSDL.
 Al experimentar con diferentes herramientas hemos detectado que debido
 a tales diferencias, en algunos casos resulta imposible derivar interfaces
 Java, y en otros casos se derivan interfaces erróneas.
 Además, al considerar el surgimiento de otro tipo de Servicios Web como
 los servicios RESTful, que presentan interfaces distintivas mediante HTTP
 o WADL, se incrementa el desafío en el tratamiento generalizado de interfaces
 de servicios.
 Por lo tanto, es necesario contar con una especificación de contratos de
 Servicios Web, que sea independiente de cualquier tecnología de implementación.
 Por este motivo, utilizando como base los estándares mencionados en la
 Sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Background"

\end_inset

, SoaML, WSDL y WADL, se ha definido e implementado un Metamodelo para Descripci
ón de Contratos de Servicios Web.
 La Figura
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Diagrama-de-clases"

\end_inset

 muestra el diagrama de clases del metamodelo definido, que se explicará
 en la Sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Vision-Detallada"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename ImgChapter3/usadas/CBR 4SS.png
	lyxscale 70
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Esquema-de-proceso"

\end_inset

Esquema de proceso propuesto
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Vision-Detallada"

\end_inset

Visión Detallada
\change_inserted -746951894 1534194198

\end_layout

\begin_layout Standard

\change_inserted -746951894 1534194200
\begin_inset Note Note
status open

\begin_layout Plain Layout

\change_inserted -746951894 1534194877
Esta 
\begin_inset Quotes eld
\end_inset

vision detallada
\begin_inset Quotes erd
\end_inset

 es en realidad la intro de la sección.
 Despues discutir en detalle cada una, ver el paper de CBR.
 Por ejemplo:
\end_layout

\begin_layout Plain Layout

\change_inserted -746951894 1534194877
Numerar los pasos en la figura (find, resolve, revise, retrain, discard,
 etc).
 Luego usar esa numeración para describir cada parte del proceso en la visión
 detallada.
\end_layout

\begin_layout Plain Layout

\change_inserted -746951894 1534194827
1.
 Case Representation.
 entra un caso (como esta compuesto?) que tiene que ver con el metamodelo?
 Ejemplificar
\change_unchanged

\end_layout

\begin_layout Plain Layout

\change_inserted -746951894 1534194837
2.
 KB.
 Persistencia, noSQL , json-oriented.
 Ejemplo!
\end_layout

\begin_layout Plain Layout

\change_inserted -746951894 1534194854
3.
 Find Similarity (Case retrieval en el paper CBR).
 se evalua segun la funcion (mostrar la funcion de distanca, explicarla).
 Ejemplo.
 
\end_layout

\begin_layout Plain Layout

\change_inserted -746951894 1534194991
4.
 Resolve Case (Reuse and Revision en CBR): Técnicas (knn, 1-nn) cual se
 usó, por qué? Es configurable! No se está haciendo la parte de adaptación
 del caso (debido al dominio de aplicación)
\end_layout

\begin_layout Plain Layout

\change_inserted -746951894 1534195019
5.
 Evaluate and Case Retrain (Case Retraining en el paper de CBR).
 
\change_unchanged

\end_layout

\end_inset


\change_unchanged

\end_layout

\begin_layout Standard
En esta sección se describe cada 
\emph on
paso
\emph default
 que compone al diagrama de flujo de la Figura
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Esquema-de-proceso"

\end_inset

.
 El mismo comienza cuando se ingresa al sistema una consulta, un caso, conproble
ma y sin solución, éste es llamado 
\emph on
New Case
\emph default
, lo que sucede a continuación es que se compara uno a uno con los casos
 de la base de conocimiento (
\emph on
Knowledge Base
\emph default
), de los cuales ya se tiene la solución.
 Se calcula cuán distinto es el problema del nuevo caso con cada uno de
 los demás problemas, para ésto se utiliza la funcion de distancia del 
\emph on
Metamodelo.
 
\emph default
La distancia entre dos casos nos indica cuán parecido son sus problemas,
 una distancia de 0.0 nos indica que los problemas son exactamente iguales,
 por el contrario una distancia de 4.0 nos indica que ambas interfaces son
 totalmente incompatibles.
 La distancia nos indica además, el esfuerzo que va a requerir adaptar ambas
 interfaces, siendo 0.0 ningún esfuerzo, y 4.0 imposible.
 Una distancia entre esos dos valores, nos indica que deberemos crear componente
s para utilizar el patrón de diseño adapter y, de esta manera permitir la
 compatibilidad entre ambos servicios.
 Para seleccionar el servicio adecuado se útilizan métodos de selección
 como 
\emph on
KNN 
\emph default
y derivados 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Explicar los demas casos
\end_layout

\end_inset

.
 
\emph on
KNN 
\emph default
consiste en tomar los 
\emph on
K
\emph default
 casos que tengan menor distancia con el caso requerido, una vez obtenido
 estos K casos se realiza una votación por solución (puesto a que dos casos
 en la base de conocimiento pueden tener la misma solución) y el caso de
 menor distancia dentro de la solución 
\begin_inset Quotes eld
\end_inset

ganadora
\begin_inset Quotes erd
\end_inset

 pasa a ser el caso candidato (
\emph on
Solved Case
\emph default
), en caso de que la hubiese un empate en la votación, la misma se desempata
 tomando como caso candidato al que tuviese ménos distancia, dentro de las
 soluciones que hayan empatado.
 El caso candidato se presenta al consumidor y éste decide si la solución
 es compatible o no, en caso de que no lo sea, dicha solución es descartada
 y el consumidor puede volver a iniciar el proceso de resolución si éste
 lo desea.
 
\end_layout

\begin_layout Standard
Si la solución es compatible, se evalúa la calidad de la respuesta, para
 ésto se compara un valor de 
\emph on
threshold
\emph default
, si la solución tiene un valor mayor que el establecido, el nuevo caso
 con su solución son agregados a la base de conocimiento y, de ésta manera,
 es tomada en cuenta para nuevos casos.
 En caso de que el valor sea menor que el establecido, éste caso no se agrega,
 debido a que generaría ruidos y posiblemente haría overfitting al proceso,
 haciendo que al llegar un nuevo caso, genere falsos positivos, es decir
 que diga que no hay distancia entre el caso requerido y uno de la base
 de conocimiento, cuando en realidad hay una distancia.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Cambios-necesarios"

\end_inset

Cambios necesarios
\end_layout

\begin_layout Standard
En el diagrama de flujo de la Figura
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Esquema-de-proceso"

\end_inset

 se puede observar dentro del cuadro con bordes punteados como se componen
 las clases pertenecientes al Metamodelo SoaML, el mismo cumple su función
 como descriptor de interfaces, pero no tiene toda la información necesaria
 para operar dentro del contexto de un CBR.
\end_layout

\begin_layout Standard
Por lo tanto fue necesario realizar adaptaciones con el fin de operar dentro
 del marco de 
\emph on
Razonamiento Basado en Casos (CBR)
\emph default
.
\end_layout

\begin_layout Standard
Dichos cambios consisten en la creación de una nueva clase contenedora llamada
 
\emph on
Case
\emph default
, la misma posee un atributo llamado 
\emph on
problem
\emph default
, referenciando a la 
\emph on
Interface 
\emph default
descriptora del servicio, y otro atributo nombrado 
\emph on
solution
\emph default
, siendo éste un string que referencia unequivocamente la solución del problema
 descripto, el mismo puede ser cadena nula si se trata de un nuevo caso
 a consultar.
\end_layout

\begin_layout Standard
Es de gran importancia para el funcionamiento del 
\emph on
Razonamiento Basado en Casos (CBR)
\emph default
 almacenar los casos en una 
\emph on
Base de Conocimiento 
\emph default
(
\emph on
Knowledge Base
\emph default
 o KB), en la cual luego podremos hacer consultas, para la implementación
 de dicha base de conocimiento se decidió utilizar una Base de Datos sin
 esquema (NoSQL) llamada 
\emph on
Mongo 
\emph default

\begin_inset Note Note
status open

\begin_layout Plain Layout
Apartado mongo?
\end_layout

\end_inset

.
 Para poder almacenar nuestro caso en una base de datos lo ideal es serializarlo
, para obtener el valor de la base de datos se debe des serializar.
 Para realizar ambas acciones se optó por utilizar la librería 
\emph on
Jackson
\begin_inset Foot
status open

\begin_layout Plain Layout

\emph on
https://github.com/FasterXML/jackson-module-kotlin
\end_layout

\end_inset


\emph default
, que es el estardar de facto para realizar dichas tareas en Kotlin.
 Debido a que 
\emph on
Parameter
\emph default
 referencia al tipo de dato abstracto 
\emph on
Type
\emph default
, al momento de des serializarlo es necesario especificar a qué clase concreta
 pertenece el dato en cuestión, para ésto fue necesario modificar los constructo
res de la clase 
\emph on
Type
\emph default
, añadiendo anotaciones 
\emph on
(Annotations
\begin_inset Foot
status open

\begin_layout Plain Layout

\emph on
https://docs.oracle.com/javase/7/docs/technotes/guides/language/annotations.html
\end_layout

\end_inset

) 
\emph default
a los mismos, las anotaciones siguen el patrón decorator
\begin_inset CommandInset citation
LatexCommand cite
key "GoF"

\end_inset

.
\end_layout

\begin_layout Standard
Con estos cambios fue posible la utilización del Metamodelo SoaML dentro
 del contexto de 
\emph on
Razonamiento Basado en Casos (CBR)
\emph default
.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:-Conversor de OAS"

\end_inset

Conversor de OAS para instanciar el Metamodelo de Servicios Web
\end_layout

\begin_layout Standard
En la Sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Relación-entre-OAS"

\end_inset

 se analiza la relación existente entre el estándar OAS (Open Api Specification)
 y el metamodelo utilizado como modelador de problema, utilizando como soporte
 a la explicación un caso de estudio.
 Esta relación se analizará en profundidad, detallando la relación entre
 los componentes del Metamodelo y los de OAS.
 Finalmente se muestra un diagrama de objetos instanciados de acuerdo al
 caso de estudio.
\end_layout

\begin_layout Standard
En la Sección
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Construcción-del-instanciador"

\end_inset

, se explica como se construyó el componente Conversor del metamodelo propuesto,
 detallando las estructuras de datos analizadas y el proceso de análisis
 que se realiza para poder instanciar el metamodelo a partir de una descripción
 OAS.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Casi todo lucas
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Relación-entre-OAS"

\end_inset

Relación entre OAS y Metamodelo
\end_layout

\begin_layout Standard
En esta subsección se detalla la correlación entre el estándar OAS y el
 Metamodelo de Servicios Web, para lo cual se utilizará un caso de estudio
 sencillo como soporte a la explicación.
 
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:Caso-de-estudio"

\end_inset

Caso de estudio
\end_layout

\begin_layout Standard
Durante el desarrollo de este trabajo se tomará como soporte a la explicación,
 un Servicio Web perteneciente al dominio de veterinaria (PetStore).
 El diagrama de clases UML para este dominio es presentado en la Figura
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig: caso de estudio-1"

\end_inset

 en donde referenciaremos las operaciones con el formato 
\emph on
{Método HTTP}_{URI}
\emph default
 para que puedan ser identificadas inequívocamente.
 En el dominio de veterinaria, el servicio está compuesto por 5 operaciones
 encapsuladas en la interfaz petStore, 
\emph on
POST_/pet, GET_/pet/{petId}, POST_/pet/{petId}, DELETE_/pet/{petId} y POST_/pet/
{petId}/uploadImage
\emph default
.
 La operación 
\emph on
POST_/pet
\emph default
 es utilizada para agregar mascotas a la base de datos, devolviendo los
 datos de la mascota, y un id único.
 Para 
\emph on
GET_/pet/{petId}
\emph default
, dado un id de una mascota, retorna la información de esa mascota, a su
 vez 
\emph on
POST_/pet/{petId} 
\emph default
recibe el mísmo id de la mascota, más los datos a actualizar de la misma,
 
\emph on
DELETE_/pet/{petId}
\emph default
 recibe el id de la mascota a eliminar.
 Finalmente, 
\emph on
POST_/pet/{petId}/uploadImage
\emph default
 es una operación que permite subir fotos de la mascota dado su id.
 En el Listado de Código 
\begin_inset CommandInset ref
LatexCommand ref
reference "Documento OAS PetStore"

\end_inset

 se muestra un fragmento del documento OAS que describe el servicio 
\emph on
PetStore
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ImgChapter3/usadas/OAS vs Metamodelo.png
	lyxscale 50
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig: caso de estudio-1"

\end_inset

Visión esquemática UML del Caso de estudio
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "listing/petStore (ejemplo).txt"
lstparams "caption={Documento OAS PetStore},label={Documento OAS PetStore}"

\end_inset


\end_layout

\begin_layout Paragraph
OAS vs.
 Metamodelo
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Explicar el evaluador no incluye los simbolos
\end_layout

\end_inset

En el fragmento de OAS – Listado de Código
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "Documento OAS PetStore"

\end_inset

, línea 
\begin_inset Note Note
status open

\begin_layout Plain Layout
DEFINIR
\end_layout

\end_inset

 –, se define para la interfaz (
\emph on
interface
\emph default
) del servicio, la operación (
\emph on
operation
\emph default
) 
\emph on
GET_/pet/{petId}
\emph default
, indicando la entrada y salida de la misma utilizando las keys 
\emph on
parameters
\emph default
 y 
\emph on
responses[200] 
\emph default
respectivamente.
 Cada entrada y cada salida se representa como una entrada del documento
 OAS.
 Los elementos que conforman las entradas y salidas de las operaciones se
 detallan dentro del apartado 
\emph on
types
\emph default
 del documento.
 Entre las líneas 
\begin_inset Note Note
status open

\begin_layout Plain Layout
DEFINIR
\end_layout

\end_inset

, se aprecia como se encuentra conformada la sección 
\emph on
definitions.

\emph default
 A su vez, la operación 
\emph on
GET_/pet/{petId}
\emph default
 se detalla desde la línea 
\begin_inset Note Note
status open

\begin_layout Plain Layout
46 hasta la 66
\end_layout

\end_inset

 inclusive.
\end_layout

\begin_layout Standard
Por un lado, 
\emph on
parameters 
\emph default
– línea 
\begin_inset Note Note
status open

\begin_layout Plain Layout
46
\end_layout

\end_inset

 – define la entrada de dicha operación.
 La misma está compuesta por un objeto del tipo entero (
\emph on
integer - int64
\emph default
).
 Por otro lado, el objeto dentro de la clave 
\emph on
200
\emph default
, dentro del objeto 
\emph on
response 
\emph default
– línea 
\begin_inset Note Note
status open

\begin_layout Plain Layout
54
\end_layout

\end_inset

 – es un objeto que encapsula la salida de la operación, cuyo esquema es
 una referencia a 
\emph on
#/definitions/Pet
\emph default
, lo que nos indica que debemos ver la definición en la propiedad 
\emph on
Pet
\emph default
 del objeto 
\emph on
definitions
\emph default
, la misma define sus propiedades en el atributo 
\emph on
properties
\emph default
, compuesto por: un identificador 
\emph on
id
\emph default
, una categoría 
\emph on
category
\emph default
, un nombre 
\emph on
name
\emph default
 y un listado de fotos 
\emph on
photoUrls
\emph default
.
\end_layout

\begin_layout Standard
En la Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:EjemploVersionInstanciada"

\end_inset

 se muesta el diagrama de objetos que representa la salida (instancia del
 metamodelo) generada por el componente Conversor para el documento OAS
 utilizado como ejemplo.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Es singleton O lo saco?
\end_layout

\end_inset

Es importante destacar que la estructura de datos utilizada generará una
 sola vez los tipos de datos, y si fuera necesario realizar otra instancia
 de la misma clase, se fija la dirección de memoria mediante un puntero
 a aquella que fue creada por primera vez.
 Esto quiere decir que sólo existirá una instancia por cada tipo definido
 dentro del documento.
 Por ejemplo sólo va a existir una instancia que representa al tipo simple
 
\emph on
string
\emph default
, y cada elemento relacionado con este tendrá una referencia a dicha instancia.
\end_layout

\begin_layout Standard
En el diagrama de objetos de la Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:EjemploVersionInstanciada"

\end_inset

 se puede observar una instancia de la clase 
\emph on
Interface
\emph default
, llamada 
\emph on
PetStore
\emph default
 la cual agrupa las operaciones que ofrece el servicio.
 Recordamos que este servicio cuenta con cuatro operaciones, cada una asociada
 a su respectiva entrada y salida (
\emph on
input
\emph default
/
\emph on
output
\emph default
).
 A su vez cada entrada/salida está relacionada con los parámetros que las
 componen.
 Con el fin de mostrar a manera resumida como queda la instancia del metamodelo,
 solo se detalla la función 
\emph on
GET_/pet/{petId}
\emph default
.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ImgChapter3/usadas/OAS vs Metamodelo (instancia).png
	lyxscale 50
	width 100col%
	scaleBeforeRotation

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:EjemploVersionInstanciada"

\end_inset

Ejemplo de metamodelo instanciado para el caso de estudio
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\change_inserted -746951894 1534193993
\begin_inset Note Note
status open

\begin_layout Plain Layout

\change_inserted -746951894 1534194049
Se puede separar en dos imagenes.
 Para ponerlas una al lado de la otra hacer un float, con dos float adentro
 (sin espacio en blanco entre ellos) y el ancho de cada figura adentro debe
 ser 49% o menos
\change_unchanged

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[!htb]
\end_layout

\begin_layout Plain Layout

   
\backslash
begin {minipage}{0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

     
\backslash
centering
\end_layout

\begin_layout Plain Layout

     
\backslash
includegraphics[width=1.0
\backslash
linewidth]{ImgChapter3/usadas/getPetById-(anotado).png}
\end_layout

\begin_layout Plain Layout

     
\backslash
caption{Componentes de Operación}
\backslash
label{fig:Componentes-de-Operacion}
\end_layout

\begin_layout Plain Layout

   
\backslash
end{minipage}
\backslash
hfill
\end_layout

\begin_layout Plain Layout

   
\backslash
begin {minipage}{0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

     
\backslash
centering
\end_layout

\begin_layout Plain Layout

     
\backslash
includegraphics[width=1.0
\backslash
linewidth]{ImgChapter3/usadas/getPetByIdDefinitions-(anotado).png}
\end_layout

\begin_layout Plain Layout

     
\backslash
caption{Componentes de Tipos de datos}
\backslash
label{fig:Componentes-de-Tipos-de-datos}
\end_layout

\begin_layout Plain Layout

   
\backslash
end{minipage}
\backslash
hfill
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Tipos de datos simple
\end_layout

\begin_layout Standard
Los tipos de datos primitivos en la especificación Open API se basan en
 los tipos admitidos por la Especificación de esquema JSON (Borrador 00)
\begin_inset Note Note
status open

\begin_layout Plain Layout
referencia?
\end_layout

\end_inset

.
 Null no es compatible como tipo.
 
\end_layout

\begin_layout Standard
Los tipos de datos primitivos tienen una propiedad modificadora opcional:
 
\emph on
format
\emph default
.
 La especificación Open API utiliza varios formatos conocidos para definir
 en detalle el tipo de datos que se utiliza.
 Sin embargo, para mantener las necesidades de la documentación, la propiedad
 format puede tener cualquier valor.
 Los formatos como "email", "uuid", etc., PUEDEN usarse aunque no estén definidos
 por esta especificación.
 Los tipos que no poseen la propiedad format siguen la definición de tipo
 del esquema JSON.
 Ésta herramienta, al no encontrarse con un format no especificado PUEDE
 utilizar el tipo predeterminado.
\end_layout

\begin_layout Standard
Adicionalmente, un tipo de dato primitivo “file” es usado por el objeto
 Parameter y Response para denotar que el tipo del parámetro o de respuesta
 es un archivo.
 
\end_layout

\begin_layout Standard
Todos los tipos de datos simple soportados por la especificación Open API
 están incluidos en los tipos de datos definidos por el Metamodelo, como
 se puede observar en el Cuadro 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Correspondencia-Tipos-de-datos"

\end_inset

.
 El mismo contiene cinco columnas, en la columna 
\emph on
Nombre
\emph default
 se puede observar el nombre coloquial que se le da al tipo de dato, las
 columnas 
\emph on
Type
\emph default
 y 
\emph on
Format
\emph default
 son las propiedades que definen el dato en la especificación, y por último
 la columna 
\emph on
SimpleType 
\emph default
indica el 
\emph on
tipo 
\emph default
que se le asigna a la instancia de SimpleType correspondiente.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="12.5text%">
<column alignment="center" valignment="top" width="10text%">
<column alignment="center" valignment="top" width="12.5text%">
<column alignment="center" valignment="top" width="35text%">
<column alignment="center" valignment="top" width="25text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Nombre
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Format
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Comentarios
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
SimpleType
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
int32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
32 bits con signo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
INTEGER
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
long
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
int64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
64 bits con signo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
LONG
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
float
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
number
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
float
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
FLOAT
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
double
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
number
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
double
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
DOUBLE
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
string
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
string
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
STRING
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
byte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
string
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
byte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Caracteres codificados en base64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
BASE64
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
string
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Cualquier secuencia de octales
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
BYTE
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
boolean 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
boolean
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
BOOLEAN
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
date
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
string
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
date
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Como se define full-date en RFC3339
\begin_inset Note Note
status open

\begin_layout Plain Layout
referencia?
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
DATE
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
dateTime
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
string
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
date-time
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Como se define date-time en RFC3339
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
DATE_TIME
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
password
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
string 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
password
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Especifica que la UI debe ofuscar el input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
STRING
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
file
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
file
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
BASE64_BINARY
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Correspondencia-Tipos-de-datos"

\end_inset

Correspondencia Tipos de datos Simple con Metamodelo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Construcción-del-instanciador"

\end_inset

Construcción del Conversor
\end_layout

\begin_layout Standard
En los siguientes párrafos se detallan los pasos principales para la construcció
n del Conversor.
 Primeramente fue necesario analizar las herramientas que se encuentran
 disponibles que podrían ser potencialmente útiles a la hora de implementar
 el módulo de software Conversor del Metamodelo.
 Luego se explica en detalle el proceso de conversión de documentos WSDL
 2.0 a instancias del metamodelo junto con los algoritmos involucrados para
 realizar dichas operaciones.
 
\end_layout

\begin_layout Paragraph
\begin_inset CommandInset label
LatexCommand label
name "par:Selección-del-lenguaje"

\end_inset

Selección del lenguaje de programación utilizado
\end_layout

\begin_layout Standard
El Metamodelo y la herramienta de evaluación de servicio web están realizadas
 en Java, Java es un lenguaje muy popular, pero a veces se suele desperdiciar
 mucho tiempo, o caracteres, en escribir lógica que se podría redactar de
 manera más simple.
 Es por ello, entre otras cosas, que se decidió usar Kotlin, un lenguaje
 que se ejecuta sobre la JVM (Java Virtual Machine) y simplifica el trabajo
 del desarrollador, el cual pasa menos tiempo escribiendo lógica ajena al
 dominio.
 Un aspecto importante que destacar es que Kotlin al compilar a Bytecode
 y correr sobre la JVM, es totalmente interoperable con Java, es decir,
 desde nuestro código Kotlin podemos utilizar clases y métodos Java y viceversa,
 inclusive podemos tener un proyecto mixto, en donde coexistan clases Java
 y Kotlin.
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "ventajas-kotlin"

\end_inset

Entre algunas de las ventajas de Kotlin, se encuentran: 
\end_layout

\begin_layout Itemize
Constructores de clase por defecto, sólo es necesario declarar las variables
 de clase una vez.
\end_layout

\begin_layout Itemize

\emph on
Setters
\emph default
 y 
\emph on
getters
\emph default
 implícitos, es decir, a menos que se desee cambiar el comportamiento de
 los mismos no es necesario escribirlos, además el lenguaje al compilar
 a Bytecode reemplazará los accesos y asignaciones directas a atributos,
 por los llamados a las funciones setter y getter, con lo cual el código
 se vuelve más legible.
\end_layout

\begin_layout Itemize
Tipo de clase 
\emph on
Data
\emph default
, la cual está pensada para almacenar datos, por lo tanto infiere los métodos
 
\emph on
equals
\emph default
,
\emph on
 hashCode
\emph default
, 
\emph on
toString
\emph default
 y 
\emph on
copy
\emph default
 de los atributos.
\end_layout

\begin_layout Standard
Sólo con estas ventajas, logramos que nuestra clase 
\emph on
Case
\emph default
 tenga únicamente 10 lineas de código, cuando su equivalente funcional en
 Java tendría aproximadamente 121, esto representa un 91.73% ménos de código,
 sin contar que es semánticamente mas legible.
 Además, a menos que se especifique lo contrario, ninguna variable puede
 tomar el valor null, esto nos previene de NullPointerException inesperados.
\end_layout

\begin_layout Paragraph
\begin_inset CommandInset label
LatexCommand label
name "subsec:Proceso-de-selección"

\end_inset

Selección de herramientas para construcción de módulo de software Conversor
 del Metamodelo
\end_layout

\begin_layout Standard
Tomando como base la explicación detallada en la Sección 
\emph on
YYYYY
\emph default

\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Detalle-de-selección"

\end_inset

, donde se analizaron las herramientas evaluadas para ser utilizadas potencialme
nte por el módulo de software Conversor del Metamodelo, en la presente sección
 se pretende destacar ventajas y desventajas de dichas herramientas.
 En principio, resultó necesario satisfacer la necesidad de parsear una
 especificacón Open API.
 Para ello se analizaron las herramientas
\emph on
 swagger-parser
\emph default
 y 
\emph on
KaiZen OpenAPI Parser
\emph default
.
 Luego de este análisis, 
\emph on
swagger-parser
\emph default
 resultaró ser el candidatos más apropiados para la construcción del módulo
 de software Conversor.
 
\end_layout

\begin_layout Paragraph
Motivos principales por los cuales no se utilizaron las siguientes herramientas
 
\begin_inset CommandInset label
LatexCommand label
name "par:UtilizacionHerramientasProcSwagger"

\end_inset


\end_layout

\begin_layout Itemize
PONGO UNA LISTA SI DESCARTO UNA SOLA???
\end_layout

\begin_layout Itemize
KaiZen OpenAPI Parser: Buscar desventajas
\end_layout

\begin_layout Itemize
\begin_inset Note Note
status open

\begin_layout Itemize

\series bold
JWSDL:
\series default
 posee un inconveniente fundamental (éste figura en la documentación y se
 pudo comprobar en la práctica) por el cual no se utilizó esta herramienta
 para manipular documentos WSDL.
 Cualquier hijo de <types> (dentro del documento) es tratado como elemento
 de una extensión que no se encuentra implementada entre sus funciones.
 Debido a esto resulta imposible poder analizar las estructuras de los tipos
 complejos, y por consiguiente las entradas y salidas de las operaciones
 dentro de un documento WSDL.
 En otras palabras, no se utilizó ya que no era posible analizar los datos
 definidos en el 
\emph on
tag
\emph default
 
\emph on
types 
\emph default
de los documentos.
 Además no soporta documentos WSDL 2.0, y la intención es concentrarse en
 las tecnologías más actuales que dispone el mercado.
 
\end_layout

\begin_layout Itemize

\series bold
SOA Membrane
\series default
: cuando se intentó acceder a los atributos, se dificultó el acceso a los
 tipos complejos de datos.
 Esto es porque no se pudo profundizar en su contenido con el detalle necesario
 para el componente de software que se pretendía desarrollar.
 
\end_layout

\begin_layout Itemize

\series bold
EasyWSDL:
\series default
 en la teoría soporta versiones de WSDL 1.1 y 2.0, pero al intentar cargar
 el conjunto de documentos de la plataforma Mashape, un porcentaje no pudo
 ser utilizado porque no eran sintácticamente válidos según el metamodelo
 propuesto por esta herramienta.
 Debido a esto, el proceso de análisis para los documentos afectados no
 pudo continuar.
 Además, el alcance de la herramienta es extenso, coordinar con los mensajes
 de entrada y salida para la creación y/o manipulación de datos lleva un
 proceso de aprendizaje muy grande.
 Por estas razones se decidió no utilizar esta herramienta.
 
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
\begin_inset CommandInset label
LatexCommand label
name "par:Herramientas-util-instanciador"

\end_inset

Herramientas utilizadas en el Conversor
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Para la creación del módulo de software Conversor, se utilizó una herramienta
 que fué de principal relevancia a la hora de poder concretar la creación
 de dicho módulo.
 Swagger-parser permitió parsear una especificación Open API en instancias
 de Objeto Plano de Java (POJO).
 Utilizando esta herramienta, en lugar de leer y acceder de manera directa
 a los archivos, podemos ignorar la disposición de los distintos componentes
 en el mismo y concentrarnos en el mapeo OAS-SOAML.
 Como así también, tener la posibilidad de utilizar una especificación Open
 API en archivo YAML o JSON sin tener que realizar ningún refactoring adicional.
 Otra ventaja que nos brinda ésta herramienta, es la validación a nivel
 sintáctico de las especificaciones.
\end_layout

\begin_layout Itemize
\begin_inset Note Note
status open

\begin_layout Itemize

\series bold
WODEN:
\series default
 utilizada para validar que los documentos WSDL utilizados como entrada
 al Conversor del metamodelo estuvieran bien formados.
 Esto quiere decir que con WODEN se validó que los documentos utilicen las
 etiquetas (tags) definidas por la W3C para documentos WSDL, que haya correspond
encia entre mensajes, la definición de los mismos, etc.
 De esta manera, a la hora de testear la Herramienta de Evaluación de Servicios
 Web, se trabajó con documentos bien formados desde un principio.
 Además esta herramienta permitió poder trabajar con documentos WSDL versión
 1.1.
 Básicamente si se necesita trabajar con documentos WSDL 1.1, se utiliza
 una función que convierte documentos de la versión WSDL 1.1 a la versión
 de WSDL 2.0 para luego si procesarlo como entrada al componente Conversor
 del metamodelo.
 Como un ejemplo, en el Capítulo
\begin_inset space ~
\end_inset

 4, se pudo experimentar con un conjunto de 1146 archivos WSDL versión 1.1
 de Servicios Web reales que provienen de la plataforma Mashape
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://mashape.com
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
DOM: 
\series default
acorde con DOM, cualquier elemento perteneciente al proyecto de un documento
 XML es un nodo.
 De esta manera se pudo acceder a todos los detalles específicos dentro
 de un documento WSDL sin ningún tipo de restricción.
 Esta librería es una de las herramientas más usadas y populares a la hora
 de manipular documentos XML.
 En el presente trabajo se hizo énfasis en las estructuras del documento
 relevantes para el módulo de software Conversor del Metamodelo.
 Por esta razón, se prestó especial atención a la sección 
\emph on
types
\emph default
 e 
\emph on
interface
\emph default
 que son parte de los elementos que conforman un WSDL 2.0 bien formado.
 Para esto resultó especialmente útil contar con una herramienta que permitiera
 recorrer y analizar un documento WSDL de forma confiable y robusta, sin
 nigun tipo de restricción, es decir, permitiendo el acceso a la totalidad
 del documento.
 DOM cumple con las características necesarias para llevar adelante el objetivo
 de construir un instanciador automático.
 Además, DOM nos permite gracias a una de sus funciones de navegación en
 el código fuente, analizar si el documento está bien formado, es decir
 que no tenga errores sintácticos.
 
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Consideraciones generales
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Se consideran las especificaciones Swagger a parsear como válidas, es decir,
 al parsear el Swagger al Metamodelo, no garantizamos la validación de la
 api, por ejemplo, en la documentación de Swagger
\begin_inset CommandInset citation
LatexCommand cite
key "swagger2.0"

\end_inset

 se indica:
\end_layout

\begin_layout Quotation
El objeto Response 
\emph on
DEBE
\emph default
 contener al menos algún código de respuesta, y 
\emph on
DEBERÍA
\emph default
 ser la respuesta del llamado de una operación exitosa.
\end_layout

\begin_layout Standard
Por lo tanto, si esta condición no se respeta y se utiliza la herramienta
 en cuestión, se pueden obtener resultados inesperados.
 Esto simplifica la herramienta y ayuda a una generar una abstracción de
 capas.
 
\end_layout

\begin_layout Standard
Los códigos de estado HTTP son utilizados para indicar el estado de la operación
 realizada.
 
\end_layout

\begin_layout Standard
Los códigos de estado disponibles están definidos por RFC7231
\change_inserted -746951894 1534193436

\begin_inset Foot
status open

\begin_layout Plain Layout

\change_inserted -746951894 1534193437
\begin_inset Flex URL
status open

\begin_layout Plain Layout

\change_inserted -746951894 1534193438

https://tools.ietf.org/ html/rfc7231#section-6
\change_unchanged

\end_layout

\end_inset


\change_unchanged

\end_layout

\end_inset


\change_deleted -746951894 1534193440

\begin_inset CommandInset citation
LatexCommand cite
key "RFC7231-section-6"

\end_inset


\change_unchanged
 y los códigos de estado registrados se enumeran en el Registro de códigos
 de estado de la IANA
\change_inserted -746951894 1534193481

\begin_inset Foot
status open

\begin_layout Plain Layout

\change_inserted -746951894 1534193484
\begin_inset Flex URL
status open

\begin_layout Plain Layout

\change_inserted -746951894 1534193486

https://www.iana.org/ assignments/http-status-codes/http-status-codes.xhtml
\change_unchanged

\end_layout

\end_inset


\change_unchanged

\end_layout

\end_inset


\change_deleted -746951894 1534193489

\begin_inset CommandInset citation
LatexCommand cite
key "IANA"

\end_inset


\change_unchanged
.
\end_layout

\begin_layout Standard
De acuerdo a la especificación Open API, los archivos que su descripción
 se representan como objetos JSON, y cumplen con los estándatares JSON.
 YAML, al ser un superconjunto de JSON, también puede ser utilizado para
 representar una especificación Open API.
 
\end_layout

\begin_layout Standard
Todos los nombres en la especificación son sensibles a mayúsculas y minúsculas.
 
\end_layout

\begin_layout Standard
El esquema expone dos tipos de campos: Campos fijos, que tienen un nombre
 declarado, y Campos modelados, que declaran un patrón de expresiones regulares
 para el nombre del campo.
 Los campos modelados DEBEN tener nombres únicos dentro del objeto contenedor.
 Para preservar la compatibilidad de ida y vuelta entre los formatos YAML
 y JSON, se recomienda la versión 1.2 de YAML junto con algunas restricciones
 adicionales: 
\end_layout

\begin_layout Itemize
Las etiquetas DEBEN estar limitadas a aquellas permitidas por el conjunto
 de reglas de esquema JSON.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Cita o nota al pie?
\end_layout

\end_inset


\change_inserted -746951894 1534193499

\begin_inset Note Note
status open

\begin_layout Plain Layout

\change_inserted -746951894 1534193502
footnote
\change_unchanged

\end_layout

\end_inset


\change_unchanged

\end_layout

\begin_layout Itemize
Las claves utilizadas en los diccionarios YAML DEBEN estar limitadas a una
 cadena escalar, según lo definido por el conjunto de reglas de esquema
 a prueba de fallas YAML.
\end_layout

\begin_layout Standard
Si bien las API pueden ser definidas por documentos OpenAPI en formato YAML
 o JSON, no es requerido que las API en cuestión se limite a utilizar estos
 formatos, es decir, el body del request y response de dicha API y otros
 contenidos no requieren ser JSON o YAML.
\end_layout

\begin_layout Paragraph
Conversión de especificaciones Open API a instancias del metamodelo
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
El Conversor desarrollado recibe como entrada una especificación Open API
 (específicamente el 
\emph on
path 
\emph default
o URL de la misma) y devuelve como salida una instancia del metamodelo.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Los elementos de la especificación son vistos como nodos, y cada nodo se
 encuentra en un determinado nivel en la estructura de arbol, siendo N
\begin_inset script subscript

\begin_layout Plain Layout
0
\end_layout

\end_inset

 el nivel inicial, y cada vez que se desciende un nivel, el subíndice de
 N aumenta en 1 unidad.
 El nodo 
\emph on
document
\emph default
, es el nodo padre y se encuentra en el nivel N
\begin_inset script subscript

\begin_layout Plain Layout
0
\end_layout

\end_inset

.
 En el nivel N
\begin_inset script subscript

\begin_layout Plain Layout
1 
\end_layout

\end_inset

se encuentran los nodos 
\emph on
interface 
\emph default
y 
\emph on
types.

\emph default
 En 
\emph on
types 
\emph default
se definen todos los tipos de datos existentes en el documento.
 En 
\emph on
interface 
\emph default
se encuentran detalladas las operaciones (
\emph on
operation
\emph default
) que ofrece el servicio (N
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

).
 En el nivel N
\begin_inset script subscript

\begin_layout Plain Layout
3
\end_layout

\end_inset

 tenemos los mensajes de entrada (
\emph on
input
\emph default
) y de salida (
\emph on
output
\emph default
).
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Siguiendo nuestro ejemplo de base del dominio PetStore, la Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Ejemplo-versión-Dom-1"

\end_inset

 muestra un esquema de como quedaría la estructura con los distintos atributos
 que conforman una especificación Open API al parsearla con la herramienta
 Swagger-parser.
 Cabe destacar que en esta figura, solo se detalla la operación 
\emph on
GET_/pet/{petId}
\emph default
, con el objetivo de dar un ejemplo gráfico de fácil comprensión.
\end_layout

\begin_layout Standard
ACTUALIZAR IMAGEN
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ImgChapter3/DomEnEjemplo2.png
	lyxscale 30
	width 100text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Ejemplo-versión-Dom-1"

\end_inset

Ejemplo de objetos que se analizan del documento WSDL parseado con la herramient
a DOM
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A continuación se detalla el pseudocódigo del módulo de software de conversión
 de especificaciones Open API a instancias del metamodelo.
 En el Algoritmo
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Convertir-especificación-Open"

\end_inset

 la función propuesta recibe como entrada una especificación Open API –
 línea 1.
 El primer paso es parsearlo a una especificación Open API – línea 2.
 Luego por cada operación (método HTTP) que tenga cada 
\emph on
path, 
\emph default
crearemos una operación del metamodelo - línea 32, con los atributos 
\emph on
input
\emph default
, 
\emph on
output
\emph default
 y 
\emph on
faults 
\emph default
obtenidos previamente.
 Por cada 
\emph on
parameter 
\emph default
de la operación crearemos un metamodelParameter obteniendo el tipo de dato
 según el procedimiento detallado en el Algotirmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Convertir-especificación-Open"

\end_inset

, con éstos parametros crearemos nuestro input.
\end_layout

\begin_layout Standard
Cada response de la operación se analiza, ya que la misma puede ser una
 respuesta exitosa o fallida.
 En caso de ser la primera, es facil evidenciarlo, pues el 
\emph on
status code 
\emph default
de la misma comenzará con 
\emph on
2
\emph default
, si la respuesta tiene tipo se creará un parametro que luego será usado
 con el 
\emph on
output
\emph default
 - línea 22.
 En caso de ser la segunda opción, se crea un nuevo 
\emph on
Fault 
\emph default
con el tipo de la respuesta, y se agregará a la lista de 
\emph on
faults
\emph default
 - línea 26.
\end_layout

\begin_layout Standard
Una vez terminado de recorrer las operaciones de cada 
\emph on
path,
\emph default
 se crea la interfaz del metamodelo con el listado de operaciones.
 Finalmente es retornada una instancia del metamodelo generado a partir
 de la especificación Open API utilizada como entrada.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

1  function convertir_OAS_A_Metamodelo (OpenApiSpecPath ){
\end_layout

\begin_layout Plain Layout

2   openApiSpec = SwaggerParser().read(OpenApiSpecPath)
\end_layout

\begin_layout Plain Layout

3   List<Operation> operations = []
\end_layout

\begin_layout Plain Layout

4   for(path: openApiSpec.paths){
\end_layout

\begin_layout Plain Layout

5    for(operation: path.methods){
\end_layout

\begin_layout Plain Layout

6     List<Parameter> parameters = []
\end_layout

\begin_layout Plain Layout

7     for(parameter: operation.parameters){
\end_layout

\begin_layout Plain Layout

8      Parameter metamodelParameter = 'Crear metamodelParameter segun parameter'
\end_layout

\begin_layout Plain Layout

9      parameters.add(metamodelParameter)
\end_layout

\begin_layout Plain Layout

10    }
\end_layout

\begin_layout Plain Layout

11    Input input = 'Crear Input con parameters';
\end_layout

\begin_layout Plain Layout

12    Output output = null
\end_layout

\begin_layout Plain Layout

13    List<Fault> faults = []
\end_layout

\begin_layout Plain Layout

14    for(response in operation.reponses){
\end_layout

\begin_layout Plain Layout

15     Type responseType = 'Crear responseType segun response'
\end_layout

\begin_layout Plain Layout

16     if(response.statusCode.startsWith("2")){
\end_layout

\begin_layout Plain Layout

17      List<Parameter> outputParameters = []
\end_layout

\begin_layout Plain Layout

18      if(responseType != null){
\end_layout

\begin_layout Plain Layout

19       outputParameter = 'Crear outputParameter con tipo responseType'
\end_layout

\begin_layout Plain Layout

20       outputParameters.add(outputParameter)
\end_layout

\begin_layout Plain Layout

21      }
\end_layout

\begin_layout Plain Layout

22      output = 'Crear output con outputParameters'
\end_layout

\begin_layout Plain Layout

23     }
\end_layout

\begin_layout Plain Layout

24     else{
\end_layout

\begin_layout Plain Layout

25      Fault fault = 'Crear fault con tipo responseType'
\end_layout

\begin_layout Plain Layout

26      fault.add(fault)
\end_layout

\begin_layout Plain Layout

27     }
\end_layout

\begin_layout Plain Layout

28    }
\end_layout

\begin_layout Plain Layout

29    Operation metamodelOperation = 'Crear operacion con input, output
 y faults'
\end_layout

\begin_layout Plain Layout

30    operations.add(metamodelOperation)
\end_layout

\begin_layout Plain Layout

31   }
\end_layout

\begin_layout Plain Layout

32  }
\end_layout

\begin_layout Plain Layout

32  Interface metamodelInterface = 'Crear interface con operations'
\end_layout

\begin_layout Plain Layout

33  return metamodelInterface
\end_layout

\begin_layout Plain Layout

34 }
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Convertir-especificación-Open"

\end_inset

Convertir especificación Open API a Metamodelo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
\begin_inset Note Note
status collapsed

\begin_layout Paragraph
old
\end_layout

\begin_layout Plain Layout
Para evaluar los tipos de datos nos basamos principalmente en los Algoritmos
 
\begin_inset CommandInset ref
LatexCommand ref
reference "Obtener tipo de dato"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "Es tipo complejo"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "Es tipo simple"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "Obtener nombre tipo simple"

\end_inset

, donde en el primero se encuentra la lógica principal, y los restantes
 describen las funciones auxiliares.
 Los mismos cumplen la función de discriminar la estructura sintáctica de
 los programas involucrados.
 Dado un nodo como entrada a la función del primero, el análisis retorna
 si se tiene tipos de datos simples, complejos o arreglos.
\end_layout

\begin_layout Plain Layout
En los dos párrafos siguientes se explicará brevemente el funcionamiento
 del Algoritmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "Obtener tipo de dato"

\end_inset

.
 En la línea 3, se verifica si el nodo es de tipo simple, en cuyo caso se
 crea el objeto de tipo simple con sus respectivos datos.
 Luego, se analiza en la línea 5, si estamos ante la presencia de un tipo
 de dato arreglo, para lo cual consultamos sobre un atributo llamado 
\emph on
unbounded
\emph default
.
 En caso de no ser 
\emph on
unbounded
\emph default
, se retorna el tipo simple que se creó en la línea 4.
 Caso contrario, nos encontramos ante un tipo de dato arreglo (
\emph on
ArrayType
\emph default
), el cual contendrá al tipo simple previamente mencionado, siendo una colección
 de tipos simples.
 
\end_layout

\begin_layout Plain Layout
Ahora bien, si tenemos un tipo de dato complejo
\emph on
 – ComplexType
\emph default
 (línea 13) –, debemos indagar en su estructura interna, puesto que puede
 estar compuesto por más tipos de datos complejos, arreglos o tipos simples.
 Mediante llamados recursivos se construirá la estructura del tipo de dato
 complejo.
 Una vez que creamos el tipo de dato complejo, resta preguntar si el mismo
 se encuentra contenido en una estructura de arreglo, lo que nos llevará
 en caso afirmativo a crear un arreglo asociado al tipo complejo recientemente
 creado y retornarlo; caso contrario retornamos el tipo complejo previamente
 instanciado.
 
\end_layout

\begin_layout Plain Layout
Para saber si estamos ante la presencia de un tipo de dato complejo se creó
 la función 
\emph on
esTipoComplejo(Nodo nodo)
\emph default
 (Algoritmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "Es tipo complejo"

\end_inset

), en la cual se obtiene los hijos del 
\emph on
nodo 
\emph default
que entra por parámetro de la función , en caso de que por lo menos tenga
 uno, y el nombre del mismo contenga la palabra compuesta 
\emph on
ComplexType
\emph default
 estamos en presencia de un tipo de dato complejo.
 Para saber si tenemos un tipo de dato simple recurrimos a la función 
\emph on
esTipoSimple(Nodo nodo) 
\emph default
(Algoritmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "Es tipo simple"

\end_inset

).
 Se obtiene el atributo 
\emph on
type
\emph default
 del 
\emph on
nodo
\emph default
 y si coincide con algún tipo de dato simple de los definidos en la Sección
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Vision-Detallada"

\end_inset

 
\emph on
SimpleType
\emph default
, entonces efectivamente es un tipo simple.
 Por último tenemos la función 
\emph on
obtenerNombreTipoSimple(Nodo nodo) 
\emph default
(Algoritmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "Obtener nombre tipo simple"

\end_inset

) que retorna el nombre de un tipo de dato simple.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "listing/Obtener tipo de parameter.txt"
lstparams "caption={Obtener tipo de parameter},label={Obtener tipo de parameter}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "listing/Obtener tipo de dato.txt"
lstparams "caption={Obtener tipo de dato},label={Obtener tipo de dato}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "listing/Es tipo complejo.txt"
lstparams "caption={Es tipo complejo},label={Es tipo complejo}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "listing/Es tipo simple.txt"
lstparams "caption={Es tipo simple},label={Es tipo simple}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "listing/Obtener nombre tipo simple.txt"
lstparams "caption={Obtener nombre tipo simple},label={Obtener nombre tipo simple}"

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Intregracion-a-Testooj"

\end_inset

Integración a la Herramienta de Evaluación de Servicios Web 
\end_layout

\begin_layout Standard
ÉSTA SECCIÓN 5 VA????
\change_inserted -746951894 1534193261

\begin_inset Note Note
status open

\begin_layout Plain Layout

\change_inserted -746951894 1534193277
Esta sección no va
\change_unchanged

\end_layout

\end_inset


\change_unchanged

\end_layout

\begin_layout Standard
El objetivo principal del desarrollo del Metamodelo para descripción de
 Contratos de Servicios Web es contar con una especificación de la funcionalidad
 que ofrece cada servicio (independientemente de la tecnología en la cual
 esté implementado).
 Al contar con dicho metamodelo resulta necesario que la evaluación de servicios
 candidatos se realice en función de instanciaciones del metamodelo.
 Para ello, se desarrolló un componente de software que contiene al metamodelo.
 En el nuevo enfoque, tanto los requerimientos funcionales por parte de
 desarrolladores de aplicaciones orientadas a servicios, como los propios
 servicios candidatos, serán representados y comparados mediante instanciaciones
 del metamodelo desarrollado.
 
\end_layout

\begin_layout Subsection
Proceso de selección y descubrimiento modificado
\end_layout

\begin_layout Standard
En la Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Esquema-propuesto"

\end_inset

 se presenta de manera esquemática la modificación sobre el proceso de descubrim
iento y selección de Servicios Web, al considerar los dos nuevos componentes
 (metamodelo y conversor), que son parte de la nueva Herramienta de Evaluación
 de Servicios Web.
 El nuevo proceso consiste inicialmente en generar instancias del metamodelo
 propuesto a partir de los documentos WSDL correspondientes a los Servicios
 Web candidatos.
 En el Paso 1.1 se generan las instancias del metamodelo que corresponden
 al requerimiento funcional del servicio que se espera consumir por la aplicació
n – que ahora denominamos 
\begin_inset Formula $I_{C}$
\end_inset

 (Interfaz a Consumir), en vez de 
\begin_inset Formula $I_{R}$
\end_inset

 – a partir de la cual se generan consultas (
\emph on
queries
\emph default
).
 Luego en el Paso 1.2 se realizan las consultas en el registro de descubrimiento
 (tal como el de EasySOC), para obtener los documentos WSDL de los servicios
 del Proveedor, que pueden corresponder a versiones 1.1 y 2.0.
 Con estos documentos, se generan las instancias del metamodelo – que ahora
 denominamos 
\begin_inset Formula $I_{P}$
\end_inset

 (Interfaz Provista), en vez de 
\begin_inset Formula $I_{S}$
\end_inset

 – utilizando el componente Conversor para obtener el conjunto que servirá
 de entrada al Paso 2, que es la selección del servicio candidato más apto.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ImgChapter3/EsquemaMetodoNuevo.png
	width 100col%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Esquema-propuesto"

\end_inset

Modificación del Proceso de Descubrimiento y Selección de Servicios Web
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
En el procedimiento de Análisis de Compatibilidad de Interfaces, que es
 parte del Método de Selección de Servicios Web (Paso 2), se realizó una
 actualización con respecto al componente del Metamodelo.
 En la presente versión (Figura
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Análisis-de-Compatibilidad-Interfcaes"

\end_inset

), se cuentan con las instancias del metamodelo, mediante el ingreso de
 los objetos 
\begin_inset Formula $I_{P}$
\end_inset

 e 
\begin_inset Formula $I_{C}$
\end_inset

, por lo que se puede acceder a todos sus atributos en una forma directa
 para el proceso de obtención de datos de signatura y evaluación tanto semántica
 como estructural.
 Si bien en la versión anterior ilustrada en la Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Análisis-de-Compatibilidad"

\end_inset

, desde los archivos WSDL versión 1.1 se extraían los elementos de signatura,
 ingresaban las clases 
\begin_inset Formula $I_{S}$
\end_inset

 e 
\begin_inset Formula $I_{R}$
\end_inset

 y actualmente 
\begin_inset Formula $I_{P}$
\end_inset

 e 
\begin_inset Formula $I_{C}$
\end_inset

, las herramientas de soporte son las mismas: WordNet y el listado de Stop
 words.
 
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ImgChapter3/Análisis-de-Compatibilidad-Interfaces.png
	lyxscale 50
	width 98text%

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Análisis-de-Compatibilidad-Interfcaes"

\end_inset

Análisis de Compatibilidad de Interfaces
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Al realizar la integración del componente del metamodelo se adaptaron las
 estrategias subyacentes para la evaluación de servicios desde el punto
 de vista estructural y semántico presentadas en la Sección
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Compatibilidad-InterfacesOld"

\end_inset

 (Capítulo
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "cap:SOApp"

\end_inset

).
 Para ello se estableció una correspondencia entre los elementos del metamodelo
 definido y las interfaces Java utilizadas en el enfoque anterior.
\end_layout

\begin_layout Subsection
Ventajas sobre implementacion anterior 
\end_layout

\begin_layout Standard
En las versiones anteriores de la plataforma para selección de Servicios
 Web
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "DeRenzis13,castro16"

\end_inset

, la evaluación a nivel de contratos se realizaba analizando interfaces
 Java generadas a partir de documentos WSDL.
 Como se mencionó en la Sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:introMotivacion"

\end_inset

, cada proveedor de servicios utiliza diferentes versiones de WSDL para
 describir las interfaces de sus servicios.
 A la hora de evaluar Servicios Web descritos mediante archivos WSDL, era
 necesario contar con herramientas externas, para cada servicio, generar
 las clases Java en archivos separados porque se utilizaba la herramienta
 Java Reflection
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.oracle.com/technetwork/articles/java/javareflection-1536171.html
 
\end_layout

\end_inset

 como soporte para el análisis.
 Java Reflection es un mecanismo poderoso que provee el lenguaje de programación
 Java (que no existe en otros lenguajes, tal como Pascal, C o C++) el cual
 permite al programa examinarse a sí mismo (introspección), y manipular
 propiedades internas.
 Se utilizaba para acceder y explorar los archivos Java compilados (.class)
 y extraer la información de cada interfaz.
 Junto a Java Reflection, se utilizaba Paranamer
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/paul-hammant/paranamer
\end_layout

\end_inset

, cuya función era permitir obtener el acceso a los nombres de los parámetros
 de los métodos no privados y constructores en tiempo de ejecución.
 Normalmente esta información se pierde en el proceso de compilación.
 
\end_layout

\begin_layout Standard
Con la implementación actual sólo es necesario disponer de las instanciaciones
 del metamodelo sin la necesidad de que existan archivos vinculados entre
 sí.
 Esa es una importante diferencia con respecto a una herramienta externa
 para el procesamiento de WSDL como podría ser EasyWSDL, puesto que para
 cada Servicio Web se generarían los siguientes archivos Java: 
\end_layout

\begin_layout Itemize
Un archivo que incluye la definición de todas las operaciones, el cual represent
a a la clase utilizada para invocar al servicio.
\end_layout

\begin_layout Itemize
Dos archivos Java por cada operación en el servicio.
 Uno de los archivos representa un tipo complejo que encapsula las entradas
 de la operación y el otro archivo representa otro tipo de dato complejo
 que encapsula las salidas de la operación.
 
\end_layout

\begin_layout Itemize
Un archivo Java por cada tipo de dato complejo propio del dominio específico
 del servicio.
 
\end_layout

\begin_layout Standard
Además, el metamodelo propuesto ofrece mas información 
\begin_inset Quotes eld
\end_inset

semántica
\begin_inset Quotes erd
\end_inset

 correspondiente al servicio.
 Un claro ejemplo se ve en la representación de las salidas de una operación.
 En el metamodelo propuesto, la salida de una operación (output) esta compuesta
 por un nombre, que puede ser cualquier tipo de identificador que represente
 a la salida de la operación y un conjunto de parámetros que determina cada
 uno de los datos que son retornados por la operación del servicio.
 En la versión anterior de la herramienta, utilizando interfaces Java, las
 operaciones cuentan simplemente con un tipo de retorno, y en el caso de
 que la operación retorne distintos elementos, se deberá encapsular cada
 uno de ellos, aún cuando en conjunto no conformen una entidad única y distintiv
a del dominio.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "Biblio_Lic"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
